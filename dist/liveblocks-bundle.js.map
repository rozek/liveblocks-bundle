{"version":3,"file":"index.js","sources":["../node_modules/@liveblocks/core/dist/index.mjs","../node_modules/@liveblocks/client/dist/index.mjs","../src/liveblocks-bundle.ts"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"1.11.3\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (process.env.NODE_ENV === \"production\") {\n    console.error(msg);\n  } else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let flagger;\n  const promise = new Promise((res) => {\n    flagger = res;\n  });\n  if (!flagger) {\n    throw new Error(\"Should never happen\");\n  }\n  return [promise, flagger];\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function clear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    clear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction newToLegacyStatus(status) {\n  switch (status) {\n    case \"connecting\":\n      return \"connecting\";\n    case \"connected\":\n      return \"open\";\n    case \"reconnecting\":\n      return \"unavailable\";\n    case \"disconnected\":\n      return \"failed\";\n    case \"initial\":\n      return \"closed\";\n    default:\n      return \"closed\";\n  }\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getLegacyStatus() {\n    return newToLegacyStatus(this.getStatus());\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      verifyTokenPermissions(parsed, options);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          verifyTokenPermissions(parsed, options);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  function verifyTokenPermissions(parsedToken, options) {\n    if (!options.roomId && parsedToken.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      if (Object.entries(parsedToken.parsed.perms).length === 0) {\n        return;\n      }\n      for (const [resource, scopes] of Object.entries(\n        parsedToken.parsed.perms\n      )) {\n        if (resource.includes(\"*\") && hasCorrespondingScopes(options.requestedScope, scopes)) {\n          return;\n        }\n      }\n      throw new StopRetrying(\n        \"The issued access token doesn't grant enough permissions. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n  const res = await fetch2(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif (process.env.NODE_ENV !== \"production\" && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storage.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar DEFAULT_DELAY = 100;\nvar noop = () => {\n};\nvar BatchCall = class {\n  constructor(args) {\n    this.resolve = noop;\n    this.reject = noop;\n    this.promise = new Promise(noop);\n    this.args = args;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options?.size ?? DEFAULT_SIZE;\n    this.delay = options?.delay ?? DEFAULT_DELAY;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const args = calls.map((call) => call.args);\n    try {\n      const results = await this.callback(args);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(...args) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.args) === stringify(args)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(args);\n    call.promise = new Promise((resolve, reject) => {\n      call.resolve = resolve;\n      call.reject = reject;\n    });\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(callback, options) {\n  const batch = new Batch(callback, options);\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    if (state) {\n      cache.set(cacheKey, state);\n    } else {\n      cache.delete(cacheKey);\n    }\n    eventSource2.notify(state);\n  }\n  async function get(...args) {\n    const cacheKey = getCacheKey(args);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(...args);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(...args) {\n    const cacheKey = getCacheKey(args);\n    return cache.get(cacheKey);\n  }\n  return {\n    ...eventSource2,\n    get,\n    getState\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const newState = callback(state);\n    if (state === newState) {\n      return;\n    }\n    state = newState;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    callback(state);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    subscribe\n  };\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url.toString();\n}\n\n// src/notifications.ts\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY = 50;\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher\n}) {\n  async function fetchJson(endpoint, options, params) {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    const url = urljoin(baseUrl, `/v2/c${endpoint}`, params);\n    const response = await fetcher(url.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getInboxNotifications(options) {\n    const json = await fetchJson(\"/inbox-notifications\", void 0, {\n      limit: options?.limit,\n      since: options?.since?.toISOString()\n    });\n    return {\n      threads: json.threads.map((thread) => convertToThreadData(thread)),\n      inboxNotifications: json.inboxNotifications.map(\n        (notification) => convertToInboxNotificationData(notification)\n      ),\n      deletedThreads: json.deletedThreads.map(\n        (info) => convertToThreadDeleteInfo(info)\n      ),\n      deletedInboxNotifications: json.deletedInboxNotifications.map(\n        (info) => convertToInboxNotificationDeleteInfo(info)\n      ),\n      meta: {\n        requestedAt: new Date(json.meta.requestedAt)\n      }\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson(\"/inbox-notifications/count\");\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" })\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nfunction nanoid(length = 7) {\n  const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n  const len = alphabet.length;\n  return Array.from(\n    { length },\n    () => alphabet.charAt(Math.floor(Math.random() * len))\n  ).join(\"\");\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items = []) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList();\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze = process.env.NODE_ENV === \"production\" ? (\n  /* istanbul ignore next */\n  (x) => x\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList();\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: user\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar CommentsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction createCommentsApi(roomId, getAuthValue, fetchClientApi) {\n  async function fetchCommentsApi(endpoint, params, options) {\n    const authValue = await getAuthValue();\n    return fetchClientApi(roomId, endpoint, authValue, options, params);\n  }\n  async function fetchJson(endpoint, options, params) {\n    const response = await fetchCommentsApi(endpoint, params, options);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new CommentsApiError(response.statusText, response.status);\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getThreads(options) {\n    const response = await fetchCommentsApi(\n      \"/threads/search\",\n      {\n        since: options?.since?.toISOString()\n      },\n      {\n        body: JSON.stringify({\n          ...options?.query?.metadata && { metadata: options.query.metadata }\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        method: \"POST\"\n      }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: json.data.map((thread) => convertToThreadData(thread)),\n        inboxNotifications: json.inboxNotifications.map(\n          (notification) => convertToInboxNotificationData(notification)\n        ),\n        deletedThreads: json.deletedThreads.map(\n          (info) => convertToThreadDeleteInfo(info)\n        ),\n        deletedInboxNotifications: json.deletedInboxNotifications.map(\n          (info) => convertToInboxNotificationDeleteInfo(info)\n        ),\n        meta: {\n          requestedAt: new Date(json.meta.requestedAt)\n        }\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        meta: {\n          requestedAt: /* @__PURE__ */ new Date()\n        }\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThread({ threadId }) {\n    const response = await fetchCommentsApi(\n      `/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return;\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId,\n    threadId\n  }) {\n    const thread = await fetchJson(\n      \"/threads\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: threadId,\n          comment: {\n            id: commentId,\n            body\n          },\n          metadata\n        })\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(metadata)\n      }\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment2({\n    threadId,\n    commentId\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function addReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ emoji })\n      }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions/${encodeURIComponent(emoji)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getThreads,\n    getThread,\n    createThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment: deleteComment2,\n    addReaction: addReaction2,\n    removeReaction: removeReaction2\n  };\n}\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 = 50;\nfunction createRoom(options, config) {\n  const initialPresence = typeof options.initialPresence === \"function\" ? options.initialPresence(config.roomId) : options.initialPresence;\n  const initialStorage = typeof options.initialStorage === \"function\" ? options.initialStorage(config.roomId) : options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces: process.env.NODE_ENV !== \"production\" ? /* @__PURE__ */ new Map() : void 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getAuthBearerHeaderFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (process.env.NODE_ENV !== \"production\") {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (process.env.NODE_ENV !== \"production\") {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    connection: makeEventSource(),\n    // Old/deprecated API\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storage: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  async function fetchClientApi(roomId, endpoint, authValue, options2, params) {\n    const url = urljoin(\n      config.baseUrl,\n      `/v2/c/rooms/${encodeURIComponent(roomId)}${endpoint}`,\n      params\n    );\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */\n    fetch;\n    return await fetcher(url, {\n      ...options2,\n      headers: {\n        ...options2?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n  }\n  async function streamFetch(authValue, roomId) {\n    return fetchClientApi(roomId, \"/storage\", authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  async function httpPostToRoom(endpoint, body) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(config.roomId, endpoint, managedSocket.authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body)\n    });\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes),\n          isReadOnly: !canWrite\n          // Deprecated, kept for backward-compatibility\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        context.root.set(key, cloneLson(context.initialStorage[key]));\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storage.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (process.env.NODE_ENV !== \"production\") {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (process.env.NODE_ENV !== \"production\") {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    storage: eventHub.storage.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  const commentsApi = createCommentsApi(\n    config.roomId,\n    delegates.authenticate,\n    fetchClientApi\n  );\n  async function fetchNotificationsJson(endpoint, options2) {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(\n      config.roomId,\n      endpoint,\n      authValue,\n      options2\n    );\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  function getRoomNotificationSettings() {\n    return fetchNotificationsJson(\n      \"/notification-settings\"\n    );\n  }\n  function updateRoomNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      \"/notification-settings\",\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        comments: {\n          ...commentsApi\n        },\n        notifications: {\n          getRoomNotificationSettings,\n          updateRoomNotificationSettings,\n          markInboxNotificationAsRead\n        }\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getConnectionState: () => managedSocket.getLegacyStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storage.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storage.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"connection\": {\n          const cb = callback;\n          return events.status.subscribe(\n            (status) => cb(newToLegacyStatus(status))\n          );\n        }\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storage.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n\n// src/store.ts\nfunction createClientStore() {\n  const store = createStore({\n    threads: {},\n    queries: {},\n    optimisticUpdates: [],\n    inboxNotifications: {},\n    notificationSettings: {}\n  });\n  return {\n    ...store,\n    deleteThread(threadId) {\n      store.set((state) => {\n        return {\n          ...state,\n          threads: deleteKeyImmutable(state.threads, threadId),\n          inboxNotifications: Object.fromEntries(\n            Object.entries(state.inboxNotifications).filter(\n              ([_id, notification]) => notification.threadId !== threadId\n            )\n          )\n        };\n      });\n    },\n    updateThreadAndNotification(thread, inboxNotification) {\n      store.set((state) => {\n        const existingThread = state.threads[thread.id];\n        return {\n          ...state,\n          threads: existingThread === void 0 || compareThreads(thread, existingThread) === 1 ? { ...state.threads, [thread.id]: thread } : state.threads,\n          inboxNotifications: inboxNotification === void 0 ? state.inboxNotifications : {\n            ...state.inboxNotifications,\n            [inboxNotification.id]: inboxNotification\n          }\n        };\n      });\n    },\n    updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads, deletedInboxNotifications, queryKey) {\n      store.set((state) => ({\n        ...state,\n        threads: applyThreadUpdates(state.threads, {\n          newThreads: threads,\n          deletedThreads\n        }),\n        inboxNotifications: applyNotificationsUpdates(\n          state.inboxNotifications,\n          {\n            newInboxNotifications: inboxNotifications,\n            deletedNotifications: deletedInboxNotifications\n          }\n        ),\n        queries: queryKey !== void 0 ? {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false\n          }\n        } : state.queries\n      }));\n    },\n    updateRoomInboxNotificationSettings(roomId, settings, queryKey) {\n      store.set((state) => ({\n        ...state,\n        notificationSettings: {\n          ...state.notificationSettings,\n          [roomId]: settings\n        },\n        queries: {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false\n          }\n        }\n      }));\n    },\n    pushOptimisticUpdate(optimisticUpdate) {\n      store.set((state) => ({\n        ...state,\n        optimisticUpdates: [...state.optimisticUpdates, optimisticUpdate]\n      }));\n    },\n    setQueryState(queryKey, queryState) {\n      store.set((state) => ({\n        ...state,\n        queries: {\n          ...state.queries,\n          [queryKey]: queryState\n        }\n      }));\n    }\n  };\n}\nfunction deleteKeyImmutable(record, key) {\n  if (Object.prototype.hasOwnProperty.call(record, key)) {\n    const { [key]: _toDelete, ...rest } = record;\n    return rest;\n  }\n  return record;\n}\nfunction compareThreads(thread1, thread2) {\n  if (thread1.updatedAt && thread2.updatedAt) {\n    return thread1.updatedAt > thread2.updatedAt ? 1 : thread1.updatedAt < thread2.updatedAt ? -1 : 0;\n  } else if (thread1.updatedAt || thread2.updatedAt) {\n    return thread1.updatedAt ? 1 : -1;\n  }\n  if (thread1.createdAt > thread2.createdAt) {\n    return 1;\n  } else if (thread1.createdAt < thread2.createdAt) {\n    return -1;\n  }\n  return 0;\n}\nfunction applyOptimisticUpdates(state) {\n  const result = {\n    threads: {\n      ...state.threads\n    },\n    inboxNotifications: {\n      ...state.inboxNotifications\n    },\n    notificationSettings: {\n      ...state.notificationSettings\n    }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        result.threads[optimisticUpdate.thread.id] = optimisticUpdate.thread;\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        if (thread.updatedAt !== void 0 && thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        };\n        break;\n      }\n      case \"create-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        const inboxNotification = Object.values(result.inboxNotifications).find(\n          (notification) => notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        result.inboxNotifications[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = deleteComment(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.deletedAt\n        );\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = addReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.reaction\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = removeReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.emoji,\n          optimisticUpdate.userId,\n          optimisticUpdate.removedAt\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        result.inboxNotifications[optimisticUpdate.inboxNotificationId] = {\n          ...state.inboxNotifications[optimisticUpdate.inboxNotificationId],\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-inbox-notifications-as-read\": {\n        for (const id in result.inboxNotifications) {\n          result.inboxNotifications[id] = {\n            ...result.inboxNotifications[id],\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"update-notification-settings\": {\n        result.notificationSettings[optimisticUpdate.roomId] = {\n          ...result.notificationSettings[optimisticUpdate.roomId],\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return result;\n}\nfunction applyThreadUpdates(existingThreads, updates) {\n  const updatedThreads = { ...existingThreads };\n  updates.newThreads.forEach((thread) => {\n    const existingThread = updatedThreads[thread.id];\n    if (existingThread) {\n      const result = compareThreads(existingThread, thread);\n      if (result === 1)\n        return;\n    }\n    updatedThreads[thread.id] = thread;\n  });\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existingThread = updatedThreads[id];\n    if (existingThread === void 0)\n      return;\n    existingThread.deletedAt = deletedAt;\n    existingThread.updatedAt = deletedAt;\n    existingThread.comments = [];\n  });\n  return updatedThreads;\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1)\n        return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction upsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt?.getTime() || 0,\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction deleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      body: void 0\n    } : comment\n  );\n  if (!updatedComments.some((comment) => comment.deletedAt === void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n      comments: []\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction addReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction removeReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(info) {\n    const leave = () => {\n      const self = leave;\n      if (!info.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (info.unsubs.size === 0) {\n          teardownRoom(info.room);\n        }\n      }\n    };\n    info.unsubs.add(leave);\n    return {\n      room: info.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, options2) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    deprecateIf(\n      options2.initialPresence === null || options2.initialPresence === void 0,\n      \"Please provide an initial presence value for the current user when entering the room.\"\n    );\n    const newRoom = createRoom(\n      {\n        initialPresence: options2.initialPresence ?? {},\n        initialStorage: options2.initialStorage\n      },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomInfo = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomInfo);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? options2.shouldInitiallyConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomInfo);\n  }\n  function enter(roomId, options2) {\n    const { room, leave: _ } = enterRoom(roomId, options2);\n    return room;\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function forceLeave(roomId) {\n    const unsubs = roomsById.get(roomId)?.unsubs ?? /* @__PURE__ */ new Set();\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead\n  } = createNotificationsApi({\n    baseUrl,\n    fetcher: clientOptions.polyfills?.fetch || /* istanbul ignore next */\n    fetch,\n    authManager,\n    currentUserIdStore\n  });\n  const cacheStore = createClientStore();\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const usersStore = createBatchStore(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const roomsInfoStore = createBatchStore(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  return Object.defineProperty(\n    {\n      logout,\n      // Old, deprecated APIs\n      enter,\n      getRoom,\n      leave: forceLeave,\n      // New, preferred API\n      enterRoom,\n      // Internal\n      [kInternal]: {\n        notifications: {\n          getInboxNotifications,\n          getUnreadInboxNotificationsCount,\n          markAllInboxNotificationsAsRead,\n          markInboxNotificationAsRead\n        },\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        cacheStore,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n}\nvar NotificationsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0)\n    return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (process.env.NODE_ENV !== \"production\") {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {\n    return () => {\n    };\n  }\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n  return \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    return \"https://\" + url;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n  let context = {\n    state: \"stopped\",\n    timeoutHandle: null,\n    interval: null,\n    lastScheduledAt: null,\n    remainingInterval: null\n  };\n  function poll() {\n    if (context.state === \"running\") {\n      schedule(context.interval);\n    }\n    void callback();\n  }\n  function schedule(interval) {\n    context = {\n      state: \"running\",\n      interval: context.state !== \"stopped\" ? context.interval : interval,\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval),\n      remainingInterval: null\n    };\n  }\n  function scheduleRemaining(remaining) {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    context = {\n      state: \"running\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: setTimeout(poll, remaining),\n      remainingInterval: null\n    };\n  }\n  function start(interval) {\n    if (context.state === \"running\") {\n      return;\n    }\n    schedule(interval);\n  }\n  function restart(interval) {\n    stop();\n    start(interval);\n  }\n  function pause() {\n    if (context.state !== \"running\") {\n      return;\n    }\n    clearTimeout(context.timeoutHandle);\n    context = {\n      state: \"paused\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: null,\n      remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n    };\n  }\n  function resume() {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    scheduleRemaining(context.remainingInterval);\n  }\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n    context = {\n      state: \"stopped\",\n      interval: null,\n      lastScheduledAt: null,\n      timeoutHandle: null,\n      remainingInterval: null\n    };\n  }\n  return {\n    start,\n    restart,\n    pause,\n    resume,\n    stop\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nexport {\n  ClientMsgCode,\n  CommentsApiError,\n  CrdtType,\n  LiveList,\n  LiveMap,\n  LiveObject,\n  NotificationsApiError,\n  OpCode,\n  ServerMsgCode,\n  WebsocketCloseCodes,\n  ackOp,\n  addReaction,\n  applyOptimisticUpdates,\n  asPos,\n  assert,\n  assertNever,\n  b64decode,\n  cloneLson,\n  fancy_console_exports as console,\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToThreadData,\n  createClient,\n  deleteComment,\n  deprecate,\n  deprecateIf,\n  detectDupes,\n  errorIf,\n  freeze,\n  getMentionedIdsFromCommentBody,\n  isChildCrdt,\n  isJsonArray,\n  isJsonObject,\n  isJsonScalar,\n  isLiveNode,\n  isPlainObject,\n  isRootCrdt,\n  kInternal,\n  legacy_patchImmutableObject,\n  lsonToJson,\n  makeEventSource,\n  makePoller,\n  makePosition,\n  nn,\n  patchLiveObjectKey,\n  raise,\n  removeReaction,\n  shallow,\n  stringify,\n  stringifyCommentBody,\n  throwUsageError,\n  toPlainLson,\n  tryParseJson,\n  upsertComment,\n  withTimeout\n};\n//# sourceMappingURL=index.mjs.map","// src/index.ts\nimport { detectDupes } from \"@liveblocks/core\";\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/client\";\nvar PKG_VERSION = \"1.11.3\";\nvar PKG_FORMAT = \"esm\";\n\n// src/index.ts\nimport {\n  createClient,\n  getMentionedIdsFromCommentBody,\n  LiveList,\n  LiveMap,\n  LiveObject,\n  shallow,\n  stringifyCommentBody,\n  toPlainLson\n} from \"@liveblocks/core\";\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nexport {\n  LiveList,\n  LiveMap,\n  LiveObject,\n  createClient,\n  getMentionedIdsFromCommentBody,\n  shallow,\n  stringifyCommentBody,\n  toPlainLson\n};\n//# sourceMappingURL=index.mjs.map","import {\n  createClient,\n  LiveList, LiveMap, LiveObject\n} from \"@liveblocks/client\"\n\nconst LiveBlocks = {\n  createClient,\n  LiveList, LiveMap, LiveObject\n}\n\n// @ts-ignore allow \"window.liveblocks\"\nwindow.liveblocks = LiveBlocks\n\ndocument.dispatchEvent(\n  new CustomEvent('liveblocks',{ detail:LiveBlocks })\n)\n"],"names":["__defProp","__export","target","all","name","PKG_NAME","PKG_VERSION","PKG_FORMAT","g","dupesDocs","SPACE","error","msg","detectDupes","pkgName","pkgVersion","pkgFormat","pkgId","pkgBuildInfo","assertNever","_value","errmsg","nn","value","controlledPromise","flagger","promise","res","makeEventSource","_onetimeObservers","_observers","_buffer","pause","unpause","event","notify","subscribe","callback","subscribeOnce","waitUntil","predicate","unsub","notifyOrBuffer","clear","count","fancy_console_exports","error2","errorWithTitle","warn","warnWithTitle","badge","bold","wrap","method","message","args","wrapWithTitle","title","distance","state1","state2","chunks1","chunks2","minLen","shared","up","down","patterns","targetState","levels","parts","result","i","slice","SafeContext","initialContext","self","allowed","patchableContext","patch","pair","key","nextId","FSM","state","nameOrPattern","enterFn","promiseFn","onOK","onError","abortController","signal","done","data","reason","matches","prefix","mapping","srcState","map","type","target_","targetFn","stateOrPattern","after2","ms","timeoutID","eventName","_a","enterPatterns","pattern","cleanupFn","oldState","nextTarget","nextState","effects","effectsToRun","effect","isPlainObject","blob","entries","obj","tryParseJson","rawMessage","deepClone","b64decode","b64value","formattedValue","c","compact","items","item","compactObject","newObj","k","withTimeout","millis","timerID","timer$","_","reject","shouldDisconnect","code","shouldReauth","shouldRetryWithoutReauth","isIdle","status","newToLegacyStatus","toNewConnectionStatus","machine","BACKOFF_DELAYS","RESET_DELAY","BACKOFF_DELAYS_SLOW","HEARTBEAT_INTERVAL","PONG_TIMEOUT","AUTH_TIMEOUT","SOCKET_CONNECT_TIMEOUT","StopRetrying","LiveblocksError","nextBackoffDelay","currentDelay","delays","delay","increaseBackoffDelay","context","increaseBackoffDelayAggressively","resetSuccessCount","log","level","logger","logPrematureErrorOrCloseEvent","e","conn","ctx","isCloseEvent","logCloseEvent","details","logPermanentClose","error3","enableTracing","start","log2","unsubs","from","to","defineConnectivityEvents","statusDidChange","didConnect","didDisconnect","lastStatus","unsubscribe","currStatus","assign","createConnectionStateMachine","delegates","options","onMessage","onLiveblocksError","fireErrorEvent","errcode","err","okEvent","failedEvent","onSocketError","onSocketClose","onSocketMessage","teardownSocket","socket","capturedPrematureEvent","unconfirmedSocket","connect$","resolve","rej","actor$","didReceiveActor","waitForActorId","serverMsg","failure","sendHeartbeat","maybeHeartbeat","doc","ctx2","win","root","onNetworkOffline","onNetworkBackOnline","onVisibilityChange","cleanups","ManagedSocket","enableDebugLogging","events","cleanup","canWriteStorage","scopes","canComment","isValidAuthTokenPayload","parseAuthToken","rawTokenString","tokenParts","payload","createAuthManager","authOptions","authentication","prepareAuthentication","seenTokens","tokens","expiryTimes","requestPromises","reset","hasCorrespondingScopes","requestedScope","getCachedToken","requestOptions","now","token","resource","makeAuthRequest","fetcher","response","fetchAuthEndpoint","parsed","verifyTokenPermissions","parsedToken","getAuthValue","cachedToken","currentPromise","expiresAt","publicApiKey","authEndpoint","fetch2","endpoint","body","er","DEFAULT_BASE_URL","kInternal","eventSource","stringify","object","sortedObject","sortedObject2","DEFAULT_SIZE","DEFAULT_DELAY","noop","BatchCall","Batch","calls","call","results","index","existingCall","call2","createBatchStore","batch","cache","eventSource2","getCacheKey","setStateAndNotify","cacheKey","get","getState","createStore","initialState","subscribers","set","newState","subscriber","convertToCommentData","editedAt","createdAt","reactions","reaction","deletedAt","convertToThreadData","updatedAt","comments","comment","convertToCommentUserReaction","convertToInboxNotificationData","notifiedAt","readAt","convertToThreadDeleteInfo","convertToInboxNotificationDeleteInfo","toURLSearchParams","params","urljoin","baseUrl","path","url","MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY","createNotificationsApi","authManager","currentUserIdStore","fetchJson","authValue","userId","getAuthBearerHeaderFromAuthValue","errorBody","NotificationsApiError","getInboxNotifications","json","thread","notification","info","getUnreadInboxNotificationsCount","markAllInboxNotificationsAsRead","markInboxNotificationsAsRead","inboxNotificationIds","batchedMarkInboxNotificationsAsRead","batchedInboxNotificationIds","markInboxNotificationAsRead","inboxNotificationId","MIN_CODE","MAX_CODE","NUM_DIGITS","ZERO","nthDigit","ONE","ZERO_NINE","n","makePosition","x","y","between","after","before","pos","lastIndex","lo","hi","_between","loLen","hiLen","loCode","hiCode","size","suffix","takeN","MIN_NON_ZERO_CODE","isPos","str","lastIdx","last","convertToPos","codes","asPos","isAckOp","op","HasParent","node","NoParent","Orphaned","oldKey","oldPos","AbstractCrdt","_isLocal","newParentNode","newParentKey","id","pool","isRootCrdt","crdt","isChildCrdt","nanoid","length","alphabet","len","LiveRegister","_LiveRegister","_parentToChildren","register","parentId","parentKey","_op","_crdt","isLocal","compareNodePosition","itemA","itemB","posA","posB","LiveList","_LiveList","position","newPosition","lsonToLiveNode","parentToChildren","list","children","id2","child","deserialize","ops","parentKey2","childOps","HACK_addIntentAndDeletedIdToOperation","childOpId","creationOpToLiveNode","deletedId","indexOfItemWithSamePosition","itemWithSamePosition","makeUpdate","setDelta","delta","deleteDelta2","updates","insertDelta","deletedDelta","unacknowledgedOpId","existingItem","deleteDelta","previousIndex","newIndex","moveDelta","orphan","recreatedItemIndex","newItem","deletedItem","existingItemIndex","itemIndexAtPosition","oldPositionIndex","newKey","before2","_b","_c","indexOfItemWithSameKey","reverse","source","indexToDelete","previousKey","element","targetIndex","beforePosition","afterPosition","previousPosition","storageUpdates","childRecordId","reverseOps","updateDelta","childId","existingId","entry","liveNodeToLson","callbackfn","searchElement","fromIndex","LiveListIterator","shiftedPosition","liveList","deltaUpdates","freeze","LiveMap","_LiveMap","entries2","mappedEntries","_item","_key","isLiveNode","opId","lastUpdateOpId","previousValue","thisId","oldValue","innerIterator","iteratorValue","key2","val","LiveObject","_LiveObject","o","tuple","liveObj","deserializeToLson","isLiveStructure","creationOpToLson","isModified","reverseUpdate","keyAsString","newValue","updatedProps","reverseUpdateOp","newAttachChildOps","createCrdtOp","nodeId","isSameNodeOrChildOf","parent","isLiveList","isLiveMap","isLiveObject","isLiveRegister","cloneLson","getTreesDiffOperations","currentItems","newItems","currentCrdt","mergeObjectStorageUpdates","first","second","mergeMapStorageUpdates","mergeListStorageUpdates","mergeStorageUpdates","isJsonScalar","isJsonArray","isJsonObject","merge","updated","ImmutableRef","makeUser","presence","connectionId","canWrite","OthersRef","cachedUser","computedUser","metaUserId","metaUserInfo","oldPresence","newPresence","PatchableRef","oldData","newData","ValueRef","initialValue","DerivedRef","transformFn","otherRefs","ref","MAX_SOCKET_MESSAGE_SIZE","makeIdFactory","userToTreeNode","user","installBackgroundTabSpy","inBackgroundSince","CommentsApiError","createCommentsApi","roomId","fetchClientApi","fetchCommentsApi","getThreads","getThread","threadId","createThread","metadata","commentId","editThreadMetadata","createComment","editComment","deleteComment2","addReaction2","emoji","removeReaction2","MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2","createRoom","config","initialPresence","initialStorage","uninstallBgTabSpy","getStorageStatus","managedSocket","doNotBatchUpdates","cb","batchUpdates","lastTokenKey","onStatusDidChange","newStatus","tokenKey","eventHub","notifySelfChanged","_connectionLossTimerId","_hasLostConnection","handleConnectionLossEvent","onDidConnect","_getStorage$","refreshStorage","flushNowOrSoon","onDidDisconnect","handleServerMessage","getConnectionId","activeBatch","addToUndoStack","dispatchOps","options2","streamFetch","httpPostToRoom","sendMessages","messages","serializedPayload","nonce","resp","staticSession","dynamicSession","myPresence","_lastSelf","batchedUpdatesWrapper","currSelf","selfAsTreeNode","me","createOrUpdateRootFromMessage","updateRoot","stackSizeBefore","applyOps","_addToRealUndoStack","historyOps","onHistoryChange","othersUpdates","others","updates2","notifyStorageStatus","rawOps","output","createdNodeIds","applyOpResult","applyOp","parentNode","updatePresence","oldValues","overrideValue","onUpdatePresenceMessage","oldUser","newUser","onUserLeftMessage","onRoomStateMessage","canUndo","canRedo","onUserJoinedMessage","parseServerMessage","parseServerMessages","text","applyAndSendOps","offlineOps","userJoinedUpdate","othersPresenceUpdate","u","event2","processInitialStorage","applyResult","storageOps","elapsedMillis","messagesToFlush","serializeBuffer","updateYDoc","update","guid","clientMsg","broadcastEvent","storageOperations","_resolveStoragePromise","unacknowledgedOps","streamStorage","startLoadingStorage","getStorageSnapshot","getStorage","fetchYDoc","vector","m","undo","redo","returnValue","currentBatch","pauseHistory","resumeHistory","_lastStorageStatus","storageStatus","others_forDevTools","other","commentsApi","fetchNotificationsJson","getRoomNotificationSettings","updateRoomNotificationSettings","settings","makeClassicSubscribeFn","subscribeToLiveStructureDeeply","relatedUpdates","subscribeToLiveStructureShallowly","isRoomEventName","internalEvent","storageCallback","makeAuthDelegateForRoom","makeCreateSocketDelegateForRoom","WebSocketPolyfill","ws","createClientStore","store","deleteKeyImmutable","_id","inboxNotification","existingThread","compareThreads","threads","inboxNotifications","deletedThreads","deletedInboxNotifications","queryKey","applyThreadUpdates","applyNotificationsUpdates","optimisticUpdate","queryState","record","_toDelete","rest","thread1","thread2","existingThreads","updatedThreads","existingInboxNotifications","updatedInboxNotifications","existingNotification","compareInboxNotifications","inboxNotificationA","inboxNotificationB","MIN_THROTTLE","MAX_THROTTLE","DEFAULT_THROTTLE","MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT","MIN_LOST_CONNECTION_TIMEOUT","RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT","MAX_LOST_CONNECTION_TIMEOUT","DEFAULT_LOST_CONNECTION_TIMEOUT","RESOLVE_USERS_BATCH_DELAY","RESOLVE_ROOMS_INFO_BATCH_DELAY","getBaseUrl","createClient","clientOptions","throttleDelay","getThrottle","lostConnectionTimeout","getLostConnectionTimeout","backgroundKeepAliveTimeout","getBackgroundKeepAliveTimeout","roomsById","teardownRoom","room","leaseRoom","leave","enterRoom","existing","newRoom","newRoomInfo","enter","getRoom","forceLeave","logout","cacheStore","resolveUsers","warnIfNoResolveUsers","createDevelopmentWarning","usersStore","batchedUserIds","userIds","users","resolveRoomsInfo","warnIfNoResolveRoomsInfo","roomsInfoStore","batchedRoomIds","roomIds","roomsInfo","checkBounds","option","min","max","recommendedMin","condition","htmlEscapables","entity","markdownEscapables","LiveBlocks"],"mappings":"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","x_google_ignoreList":[0,1]}