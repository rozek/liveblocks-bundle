(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function n(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=n(r);fetch(r.href,i)}})();var Cn=Object.defineProperty,An=(t,e)=>{for(var n in e)Cn(t,n,{get:e[n],enumerable:!0})},Pn="@liveblocks/core",Ot="1.11.3",Ln="esm",Ie=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:{},Nn="https://liveblocks.io/docs/errors/dupes",Un=" ";function xn(t){console.error(t)}function Tt(t,e,n){const s=Symbol.for(t),r=`${e} (${n})`;if(!Ie[s])Ie[s]=r;else if(Ie[s]!==r){const i=[`Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${Nn+Un}`,"","Conflicts:",`- ${t} ${Ie[s]} (already loaded)`,`- ${t} ${r} (trying to load this now)`].join(`
`);xn(i)}}function W(t,e){throw new Error(e)}function S(t,e="Expected value to be non-nullable"){return t}function Dn(){let t;const e=new Promise(n=>{t=n});if(!t)throw new Error("Should never happen");return[e,t]}function P(){const t=new Set,e=new Set;let n=null;function s(){n=[]}function r(){if(n!==null){for(const y of n)f(y);n=null}}function i(y){return e.add(y),()=>e.delete(y)}function a(y){return t.add(y),()=>t.delete(y)}async function c(y){let I;return new Promise(g=>{I=i(v=>{(y===void 0||y(v))&&g(v)})}).finally(()=>I==null?void 0:I())}function o(y){n!==null?n.push(y):f(y)}function f(y){t.forEach(I=>I(y)),t.clear(),e.forEach(I=>I(y))}function _(){t.clear(),e.clear()}function b(){return t.size+e.size}return{notify:o,subscribe:i,subscribeOnce:a,clear:_,count:b,waitUntil:c,pause:s,unpause:r,observable:{subscribe:i,subscribeOnce:a,waitUntil:c}}}var Rn={};An(Rn,{error:()=>At,errorWithTitle:()=>Lt,warn:()=>J,warnWithTitle:()=>Kn});var Et="background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;",Mn="font-weight:600";function Ct(t){return typeof window>"u"?console[t]:(e,...n)=>console[t]("%cLiveblocks",Et,e,...n)}var J=Ct("warn"),At=Ct("error");function Pt(t){return typeof window>"u"?console[t]:(e,n,...s)=>console[t](`%cLiveblocks%c ${e}`,Et,Mn,n,...s)}var Kn=Pt("warn"),Lt=Pt("error");function $n(t,e){if(t===e)return[0,0];const n=t.split("."),s=e.split("."),r=Math.min(n.length,s.length);let i=0;for(;i<r&&n[i]===s[i];i++);const a=n.length-i,c=s.length-i;return[a,c]}function jn(t,e){const n=t.split(".");if(e<1||e>n.length+1)throw new Error("Invalid number of levels");const s=[];e>n.length&&s.push("*");for(let r=n.length-e+1;r<n.length;r++){const i=n.slice(0,r);i.length>0&&s.push(i.join(".")+".*")}return s.push(t),s}var Fn=class{constructor(t){this.curr=t}get current(){return this.curr}allowPatching(t){const e=this;let n=!0;const s={...this.curr,patch(r){if(n){e.curr=Object.assign({},e.curr,r);for(const i of Object.entries(r)){const[a,c]=i;a!=="patch"&&(this[a]=c)}}else throw new Error("Can no longer patch stale context")}};t(s),n=!1}},zn=1,Hn=class{get initialState(){const t=this.states.values()[Symbol.iterator]().next();if(t.done)throw new Error("No states defined yet");return t.value}get currentState(){if(this.currentStateOrNull===null)throw this.runningState===0?new Error("Not started yet"):new Error("Already stopped");return this.currentStateOrNull}start(){if(this.runningState!==0)throw new Error("State machine has already started");return this.runningState=1,this.currentStateOrNull=this.initialState,this.enter(null),this}stop(){if(this.runningState!==1)throw new Error("Cannot stop a state machine that hasn't started yet");this.exit(null),this.runningState=2,this.currentStateOrNull=null}constructor(t){this.id=zn++,this.runningState=0,this.currentStateOrNull=null,this.states=new Set,this.enterFns=new Map,this.cleanupStack=[],this.knownEventTypes=new Set,this.allowedTransitions=new Map,this.currentContext=new Fn(t),this.eventHub={didReceiveEvent:P(),willTransition:P(),didIgnoreEvent:P(),willExitState:P(),didEnterState:P()},this.events={didReceiveEvent:this.eventHub.didReceiveEvent.observable,willTransition:this.eventHub.willTransition.observable,didIgnoreEvent:this.eventHub.didIgnoreEvent.observable,willExitState:this.eventHub.willExitState.observable,didEnterState:this.eventHub.didEnterState.observable}}get context(){return this.currentContext.current}addState(t){if(this.runningState!==0)throw new Error("Already started");return this.states.add(t),this}onEnter(t,e){if(this.runningState!==0)throw new Error("Already started");if(this.enterFns.has(t))throw new Error(`enter/exit function for ${t} already exists`);return this.enterFns.set(t,e),this}onEnterAsync(t,e,n,s){return this.onEnter(t,()=>{const r=new AbortController,i=r.signal;let a=!1;return e(this.currentContext.current,i).then(c=>{i.aborted||(a=!0,this.transition({type:"ASYNC_OK",data:c},n))},c=>{i.aborted||(a=!0,this.transition({type:"ASYNC_ERROR",reason:c},s))}),()=>{a||r.abort()}})}getStatesMatching(t){const e=[];if(t==="*")for(const n of this.states)e.push(n);else if(t.endsWith(".*")){const n=t.slice(0,-1);for(const s of this.states)s.startsWith(n)&&e.push(s)}else{const n=t;this.states.has(n)&&e.push(n)}if(e.length===0)throw new Error(`No states match ${JSON.stringify(t)}`);return e}addTransitions(t,e){if(this.runningState!==0)throw new Error("Already started");for(const n of this.getStatesMatching(t)){let s=this.allowedTransitions.get(n);s===void 0&&(s=new Map,this.allowedTransitions.set(n,s));for(const[r,i]of Object.entries(e)){if(s.has(r))throw new Error(`Trying to set transition "${r}" on "${n}" (via "${t}"), but a transition already exists there.`);const a=i;if(this.knownEventTypes.add(r),a!==void 0){const c=typeof a=="function"?a:()=>a;s.set(r,c)}}}return this}addTimedTransition(t,e,n){return this.onEnter(t,()=>{const s=typeof e=="function"?e(this.currentContext.current):e,r=setTimeout(()=>{this.transition({type:"TIMER"},n)},s);return()=>{clearTimeout(r)}})}getTargetFn(t){var e;return(e=this.allowedTransitions.get(this.currentState))==null?void 0:e.get(t)}exit(t){this.eventHub.willExitState.notify(this.currentState),this.currentContext.allowPatching(e=>{var n;t=t??this.cleanupStack.length;for(let s=0;s<t;s++)(n=this.cleanupStack.pop())==null||n(e)})}enter(t){const e=jn(this.currentState,t??this.currentState.split(".").length+1);this.currentContext.allowPatching(n=>{for(const s of e){const r=this.enterFns.get(s),i=r==null?void 0:r(n);typeof i=="function"?this.cleanupStack.push(i):this.cleanupStack.push(null)}}),this.eventHub.didEnterState.notify(this.currentState)}send(t){if(!this.knownEventTypes.has(t.type))throw new Error(`Invalid event ${JSON.stringify(t.type)}`);if(this.runningState===2)return;const e=this.getTargetFn(t.type);if(e!==void 0)return this.transition(t,e);this.eventHub.didIgnoreEvent.notify(t)}transition(t,e){this.eventHub.didReceiveEvent.notify(t);const n=this.currentState,r=(typeof e=="function"?e:()=>e)(t,this.currentContext.current);let i,a;if(r===null){this.eventHub.didIgnoreEvent.notify(t);return}if(typeof r=="string"?i=r:(i=r.target,a=Array.isArray(r.effect)?r.effect:[r.effect]),!this.states.has(i))throw new Error(`Invalid next state name: ${JSON.stringify(i)}`);this.eventHub.willTransition.notify({from:n,to:i});const[c,o]=$n(this.currentState,i);if(c>0&&this.exit(c),this.currentStateOrNull=i,a!==void 0){const f=a;this.currentContext.allowPatching(_=>{for(const b of f)typeof b=="function"?b(_,t):_.patch(b)})}o>0&&this.enter(o)}};function Nt(t){return t!==null&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"}function Ut(t){return Object.entries(t)}function Xe(t){try{return JSON.parse(t)}catch{return}}function me(t){return JSON.parse(JSON.stringify(t))}function Bn(t){try{const e=t.replace(/-/g,"+").replace(/_/g,"/");return decodeURIComponent(atob(e).split("").map(function(s){return"%"+("00"+s.charCodeAt(0).toString(16)).slice(-2)}).join(""))}catch{return atob(t)}}function ze(t){return t.filter(e=>e!=null)}function Pe(t){const e={...t};return Object.keys(t).forEach(n=>{const s=n;e[s]===void 0&&delete e[s]}),e}async function lt(t,e,n){let s;const r=new Promise((i,a)=>{s=setTimeout(()=>{a(new Error(n))},e)});return Promise.race([t,r]).finally(()=>clearTimeout(s))}function ft(t){return t===4999||t>=4e3&&t<4100}function Vn(t){return t>=4100&&t<4200}function ht(t){return t===1013||t>=4200&&t<4300}function Wn(t){return t==="initial"||t==="disconnected"}function xt(t){switch(t){case"connecting":return"connecting";case"connected":return"open";case"reconnecting":return"unavailable";case"disconnected":return"failed";case"initial":return"closed";default:return"closed"}}function Dt(t){const e=t.currentState;switch(e){case"@ok.connected":case"@ok.awaiting-pong":return"connected";case"@idle.initial":return"initial";case"@auth.busy":case"@auth.backoff":case"@connecting.busy":case"@connecting.backoff":case"@idle.zombie":return t.context.successCount>0?"reconnecting":"connecting";case"@idle.failed":return"disconnected";default:return W(e,"Unknown state")}}var Rt=[250,500,1e3,2e3,4e3,8e3,1e4],Se=Rt[0]-1,Jn=[2e3,3e4,6e4,3e5],qn=3e4,Gn=2e3,Yn=1e4,Xn=1e4,Z=class extends Error{constructor(t){super(t)}},Zn=class extends Error{constructor(t,e){super(t),this.code=e}};function Mt(t,e){return e.find(n=>n>t)??e[e.length-1]}function ae(t){t.patch({backoffDelay:Mt(t.backoffDelay,Rt)})}function pt(t){t.patch({backoffDelay:Mt(t.backoffDelay,Jn)})}function mt(t){t.patch({successCount:0})}function de(t,e){const n=t===2?At:t===1?J:()=>{};return()=>{n(e)}}function _t(t){const e="Connection to Liveblocks websocket server";return n=>{t instanceof Error?J(`${e} could not be established. ${String(t)}`):J(Kt(t)?`${e} closed prematurely (code: ${t.code}). Retrying in ${n.backoffDelay}ms.`:`${e} could not be established.`)}}function Ke(t){const e=[`code: ${t.code}`];return t.reason&&e.push(`reason: ${t.reason}`),n=>{J(`Connection to Liveblocks websocket server closed (${e.join(", ")}). Retrying in ${n.backoffDelay}ms.`)}}var Qn=de(1,"Connection to WebSocket closed permanently. Won't retry.");function Kt(t){return!(t instanceof Error)&&t.type==="close"}function es(t){const e=new Date().getTime();function n(...r){J(`${((new Date().getTime()-e)/1e3).toFixed(2)} [FSM #${t.id}]`,...r)}const s=[t.events.didReceiveEvent.subscribe(r=>n(`Event ${r.type}`)),t.events.willTransition.subscribe(({from:r,to:i})=>n("Transitioning",r,"→",i)),t.events.didIgnoreEvent.subscribe(r=>n("Ignored event",r.type,r,"(current state won't handle it)"))];return()=>{for(const r of s)r()}}function ts(t){const e=P(),n=P(),s=P();let r=null;const i=t.events.didEnterState.subscribe(()=>{const a=Dt(t);a!==r&&e.notify(a),r==="connected"&&a!=="connected"?s.notify():r!=="connected"&&a==="connected"&&n.notify(),r=a});return{statusDidChange:e.observable,didConnect:n.observable,didDisconnect:s.observable,unsubscribe:i}}var ke=t=>e=>e.patch(t);function ns(t,e){const n=P();n.pause();const s=P();function r(p,h){return()=>{const A=new Zn(p,h);s.notify(A)}}const i={successCount:0,authValue:null,socket:null,backoffDelay:Se},a=new Hn(i).addState("@idle.initial").addState("@idle.failed").addState("@idle.zombie").addState("@auth.busy").addState("@auth.backoff").addState("@connecting.busy").addState("@connecting.backoff").addState("@ok.connected").addState("@ok.awaiting-pong");a.addTransitions("*",{RECONNECT:{target:"@auth.backoff",effect:[ae,mt]},DISCONNECT:"@idle.initial"}),a.onEnter("@idle.*",mt).addTransitions("@idle.*",{CONNECT:(p,h)=>h.authValue!==null?"@connecting.busy":"@auth.busy"}),a.addTransitions("@auth.backoff",{NAVIGATOR_ONLINE:{target:"@auth.busy",effect:ke({backoffDelay:Se})}}).addTimedTransition("@auth.backoff",p=>p.backoffDelay,"@auth.busy").onEnterAsync("@auth.busy",()=>lt(t.authenticate(),Yn,"Timed out during auth"),p=>({target:"@connecting.busy",effect:ke({authValue:p.data})}),p=>p.reason instanceof Z?{target:"@idle.failed",effect:[de(2,p.reason.message),r(p.reason.message,-1)]}:{target:"@auth.backoff",effect:[ae,de(2,`Authentication failed: ${p.reason instanceof Error?p.reason.message:String(p.reason)}`)]});const c=p=>a.send({type:"EXPLICIT_SOCKET_ERROR",event:p}),o=p=>a.send({type:"EXPLICIT_SOCKET_CLOSE",event:p}),f=p=>p.data==="pong"?a.send({type:"PONG"}):n.notify(p);function _(p){p&&(p.removeEventListener("error",c),p.removeEventListener("close",o),p.removeEventListener("message",f),p.close())}a.addTransitions("@connecting.backoff",{NAVIGATOR_ONLINE:{target:"@connecting.busy",effect:ke({backoffDelay:Se})}}).addTimedTransition("@connecting.backoff",p=>p.backoffDelay,"@connecting.busy").onEnterAsync("@connecting.busy",async(p,h)=>{let A=null,z=null;const Y=new Promise((K,D)=>{if(p.authValue===null)throw new Error("No auth authValue");const U=t.createSocket(p.authValue);z=U;function B(L){A=L,U.removeEventListener("message",f),D(L)}const[oe,E]=Dn();e.waitForActorId||E();function C(L){const $=Xe(L.data);($==null?void 0:$.type)===104&&E()}U.addEventListener("message",f),e.waitForActorId&&U.addEventListener("message",C),U.addEventListener("error",B),U.addEventListener("close",B),U.addEventListener("open",()=>{U.addEventListener("error",c),U.addEventListener("close",o);const L=()=>{U.removeEventListener("error",B),U.removeEventListener("close",B),U.removeEventListener("message",C)};oe.then(()=>{K([U,L])})})});return lt(Y,Xn,"Timed out during websocket connection").then(([K,D])=>{if(D(),h.aborted)throw new Error("Aborted");if(A)throw A;return K}).catch(K=>{throw _(z),K})},p=>({target:"@ok.connected",effect:ke({socket:p.data,backoffDelay:Se})}),p=>{const h=p.reason;if(h instanceof Z)return{target:"@idle.failed",effect:[de(2,h.message),r(h.message,-1)]};if(Kt(h)){if(h.code===4109)return"@auth.busy";if(ht(h.code))return{target:"@connecting.backoff",effect:[pt,_t(h)]};if(ft(h.code))return{target:"@idle.failed",effect:[de(2,h.reason),r(h.reason,h.code)]}}return{target:"@auth.backoff",effect:[ae,_t(h)]}});const b={target:"@ok.awaiting-pong",effect:p=>{var h;(h=p.socket)==null||h.send("ping")}},y=()=>{const p=typeof document<"u"?document:void 0;return(p==null?void 0:p.visibilityState)==="hidden"&&t.canZombie()?"@idle.zombie":b};if(a.addTimedTransition("@ok.connected",qn,y).addTransitions("@ok.connected",{NAVIGATOR_OFFLINE:y,WINDOW_GOT_FOCUS:b}),a.addTransitions("@idle.zombie",{WINDOW_GOT_FOCUS:"@connecting.backoff"}),a.onEnter("@ok.*",p=>{p.patch({successCount:p.successCount+1});const h=setTimeout(n.unpause,0);return A=>{_(A.socket),A.patch({socket:null}),clearTimeout(h),n.pause()}}).addTransitions("@ok.awaiting-pong",{PONG:"@ok.connected"}).addTimedTransition("@ok.awaiting-pong",Gn,{target:"@connecting.busy",effect:de(1,"Received no pong from server, assume implicit connection loss.")}).addTransitions("@ok.*",{EXPLICIT_SOCKET_ERROR:(p,h)=>{var A;return((A=h.socket)==null?void 0:A.readyState)===1?null:{target:"@connecting.backoff",effect:ae}},EXPLICIT_SOCKET_CLOSE:p=>ft(p.event.code)?{target:"@idle.failed",effect:[Qn,r(p.event.reason,p.event.code)]}:Vn(p.event.code)?p.event.code===4109?"@auth.busy":{target:"@auth.backoff",effect:[ae,Ke(p.event)]}:ht(p.event.code)?{target:"@connecting.backoff",effect:[pt,Ke(p.event)]}:{target:"@connecting.backoff",effect:[ae,Ke(p.event)]}}),typeof document<"u"){const p=typeof document<"u"?document:void 0,h=typeof window<"u"?window:void 0,A=h??p;a.onEnter("*",z=>{function Y(){a.send({type:"NAVIGATOR_OFFLINE"})}function K(){a.send({type:"NAVIGATOR_ONLINE"})}function D(){(p==null?void 0:p.visibilityState)==="visible"&&a.send({type:"WINDOW_GOT_FOCUS"})}return h==null||h.addEventListener("online",K),h==null||h.addEventListener("offline",Y),A==null||A.addEventListener("visibilitychange",D),()=>{A==null||A.removeEventListener("visibilitychange",D),h==null||h.removeEventListener("online",K),h==null||h.removeEventListener("offline",Y),_(z.socket)}})}const I=[],{statusDidChange:g,didConnect:v,didDisconnect:w,unsubscribe:O}=ts(a);return I.push(O),e.enableDebugLogging&&I.push(es(a)),a.start(),{machine:a,cleanups:I,events:{statusDidChange:g,didConnect:v,didDisconnect:w,onMessage:n.observable,onLiveblocksError:s.observable}}}var ss=class{constructor(t,e=!1,n=!0){const{machine:s,events:r,cleanups:i}=ns(t,{waitForActorId:n,enableDebugLogging:e});this.machine=s,this.events=r,this.cleanups=i}getLegacyStatus(){return xt(this.getStatus())}getStatus(){try{return Dt(this.machine)}catch{return"initial"}}get authValue(){return this.machine.context.authValue}connect(){this.machine.send({type:"CONNECT"})}reconnect(){this.machine.send({type:"RECONNECT"})}disconnect(){this.machine.send({type:"DISCONNECT"})}destroy(){this.machine.stop();let t;for(;t=this.cleanups.pop();)t()}send(t){var n;const e=(n=this.machine.context)==null?void 0:n.socket;e===null?J("Cannot send: not connected yet",t):e.readyState!==1?J("Cannot send: WebSocket no longer open",t):e.send(t)}_privateSendMachineEvent(t){this.machine.send(t)}};function He(t){return t.includes("room:write")}function $t(t){return t.includes("comments:write")||t.includes("room:write")}function rs(t){return Nt(t)&&(t.k==="acc"||t.k==="id"||t.k==="sec-legacy")}function yt(t){const e=t.split(".");if(e.length!==3)throw new Error("Authentication error: invalid JWT token");const n=Xe(Bn(e[1]));if(!(n&&rs(n)))throw new Error("Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback");return{raw:t,parsed:n}}function is(t){const e=os(t),n=new Set,s=[],r=[],i=new Map;function a(){n.clear(),s.length=0,r.length=0,i.clear()}function c(y,I){return y==="comments:read"?I.includes("comments:read")||I.includes("comments:write")||I.includes("room:read")||I.includes("room:write"):y==="room:read"?I.includes("room:read")||I.includes("room:write"):!1}function o(y){const I=Math.ceil(Date.now()/1e3);for(let g=s.length-1;g>=0;g--){const v=s[g];if(r[g]<=I){s.splice(g,1),r.splice(g,1);continue}if(v.parsed.k==="id")return v;if(v.parsed.k==="acc"){if(!y.roomId&&Object.entries(v.parsed.perms).length===0)return v;for(const[O,p]of Object.entries(v.parsed.perms))if(y.roomId){if(O.includes("*")&&y.roomId.startsWith(O.replace("*",""))||y.roomId===O&&c(y.requestedScope,p))return v}else if(O.includes("*")&&c(y.requestedScope,p))return v}}}async function f(y){var g;const I=((g=t.polyfills)==null?void 0:g.fetch)??(typeof window>"u"?void 0:window.fetch);if(e.type==="private"){if(I===void 0)throw new Z("To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.");const v=await as(I,e.url,{room:y.roomId}),w=yt(v.token);if(_(w,y),n.has(w.raw))throw new Z("The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.");return w}if(e.type==="custom"){const v=await e.callback(y.roomId);if(v&&typeof v=="object"){if(typeof v.token=="string"){const w=yt(v.token);return _(w,y),w}else if(typeof v.error=="string"){const w=`Authentication failed: ${"reason"in v&&typeof v.reason=="string"?v.reason:"Forbidden"}`;throw v.error==="forbidden"?new Z(w):new Error(w)}}throw new Error('Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: "..." }')}throw new Error("Unexpected authentication type. Must be private or custom.")}function _(y,I){if(!I.roomId&&y.parsed.k==="acc"){if(Object.entries(y.parsed.perms).length===0)return;for(const[g,v]of Object.entries(y.parsed.perms))if(g.includes("*")&&c(I.requestedScope,v))return;throw new Z("The issued access token doesn't grant enough permissions. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions")}}async function b(y){if(e.type==="public")return{type:"public",publicApiKey:e.publicApiKey};const I=o(y);if(I!==void 0)return{type:"secret",token:I};let g;y.roomId?(g=i.get(y.roomId),g===void 0&&(g=f(y),i.set(y.roomId,g))):(g=i.get("liveblocks-user-token"),g===void 0&&(g=f(y),i.set("liveblocks-user-token",g)));try{const v=await g,O=Math.floor(Date.now()/1e3)+(v.parsed.exp-v.parsed.iat)-30;return n.add(v.raw),v.parsed.k!=="sec-legacy"&&(s.push(v),r.push(O)),{type:"secret",token:v}}finally{y.roomId?i.delete(y.roomId):i.delete("liveblocks-user-token")}}return{reset:a,getAuthValue:b}}function os(t){const{publicApiKey:e,authEndpoint:n}=t;if(n!==void 0&&e!==void 0)throw new Error("You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient");if(typeof e=="string"){if(e.startsWith("sk_"))throw new Error("Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey");if(!e.startsWith("pk_"))throw new Error("Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey");return{type:"public",publicApiKey:e}}if(typeof n=="string")return{type:"private",url:n};if(typeof n=="function")return{type:"custom",callback:n};throw n!==void 0?new Error("The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint"):new Error("Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient")}async function as(t,e,n){const s=await t(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)});if(!s.ok){const a=`${(await s.text()).trim()||"reason not provided in auth response"} (${s.status} returned by POST ${e})`;throw s.status===401||s.status===403?new Z(`Unauthorized: ${a}`):new Error(`Failed to authenticate: ${a}`)}let r;try{r=await s.json()}catch(a){throw new Error(`Expected a JSON response when doing a POST request on "${e}". ${String(a)}`)}if(!Nt(r)||typeof r.token!="string")throw new Error(`Expected a JSON response of the form \`{ token: "..." }\` when doing a POST request on "${e}", but got ${JSON.stringify(r)}`);const{token:i}=r;return{token:i}}var cs="https://api.liveblocks.io",Ce=Symbol(),ds=P();ds.observable;function Be(t,...e){if(typeof t!="object"||t===null||Array.isArray(t))return JSON.stringify(t,...e);const n=Object.keys(t).sort().reduce((s,r)=>(s[r]=t[r],s),{});return JSON.stringify(n,...e)}var us=50,ls=100,$e=()=>{},fs=class{constructor(t){this.resolve=$e,this.reject=$e,this.promise=new Promise($e),this.args=t}},Ze=class{constructor(t,e){this.queue=[],this.error=!1,this.callback=t,this.size=(e==null?void 0:e.size)??us,this.delay=(e==null?void 0:e.delay)??ls}clearDelayTimeout(){this.delayTimeoutId!==void 0&&(clearTimeout(this.delayTimeoutId),this.delayTimeoutId=void 0)}schedule(){this.queue.length===this.size?this.flush():this.queue.length===1&&(this.clearDelayTimeout(),this.delayTimeoutId=setTimeout(()=>void this.flush(),this.delay))}async flush(){if(this.queue.length===0)return;const t=this.queue.splice(0),e=t.map(n=>n.args);try{const n=await this.callback(e);this.error=!1,t.forEach((s,r)=>{const i=n==null?void 0:n[r];Array.isArray(n)?t.length!==n.length?s.reject(new Error(`Callback must return an array of the same length as the number of provided items. Expected ${t.length}, but got ${n.length}.`)):i instanceof Error?s.reject(i):s.resolve(i):s.reject(new Error("Callback must return an array."))})}catch(n){this.error=!0,t.forEach(s=>{s.reject(n)})}}get(...t){const e=this.queue.find(s=>Be(s.args)===Be(t));if(e)return e.promise;const n=new fs(t);return n.promise=new Promise((s,r)=>{n.resolve=s,n.reject=r}),this.queue.push(n),this.schedule(),n.promise}clear(){this.queue=[],this.error=!1,this.clearDelayTimeout()}};function gt(t,e){const n=new Ze(t,e),s=new Map,r=P();function i(f){return Be(f)}function a(f,_){_?s.set(f,_):s.delete(f),r.notify(_)}async function c(...f){const _=i(f);if(!s.has(_))try{a(_,{isLoading:!0});const b=await n.get(...f);a(_,{isLoading:!1,data:b})}catch(b){a(_,{isLoading:!1,error:b})}}function o(...f){const _=i(f);return s.get(_)}return{...r,get:c,getState:o}}function jt(t){let e=t;const n=new Set;function s(){return e}function r(a){const c=a(e);if(e!==c){e=c;for(const o of n)o(e)}}function i(a){return n.add(a),a(e),()=>{n.delete(a)}}return{get:s,set:r,subscribe:i}}function Ve(t){const e=t.editedAt?new Date(t.editedAt):void 0,n=new Date(t.createdAt),s=t.reactions.map(r=>({...r,createdAt:new Date(r.createdAt)}));if(t.body)return{...t,reactions:s,createdAt:n,editedAt:e};{const r=new Date(t.deletedAt);return{...t,reactions:s,createdAt:n,editedAt:e,deletedAt:r}}}function Ee(t){const e=t.updatedAt?new Date(t.updatedAt):void 0,n=new Date(t.createdAt),s=t.comments.map(r=>Ve(r));return{...t,createdAt:n,updatedAt:e,comments:s}}function hs(t){return{...t,createdAt:new Date(t.createdAt)}}function We(t){const e=new Date(t.notifiedAt),n=t.readAt?new Date(t.readAt):null;return{...t,notifiedAt:e,readAt:n}}function Ft(t){const e=new Date(t.deletedAt);return{...t,deletedAt:e}}function zt(t){const e=new Date(t.deletedAt);return{...t,deletedAt:e}}function ps(t){const e=new URLSearchParams;for(const[n,s]of Object.entries(t))s!=null&&e.set(n,s.toString());return e}function Ht(t,e,n){const s=new URL(e,t);return n!==void 0&&(s.search=(n instanceof URLSearchParams?n:ps(n)).toString()),s.toString()}var ms=50;function _s({baseUrl:t,authManager:e,currentUserIdStore:n,fetcher:s}){async function r(b,y,I){const g=await e.getAuthValue({requestedScope:"comments:read"});if(g.type==="secret"&&g.token.parsed.k==="acc"){const p=g.token.parsed.uid;n.set(()=>p)}const v=Ht(t,`/v2/c${b}`,I),w=await s(v.toString(),{...y,headers:{...y==null?void 0:y.headers,Authorization:`Bearer ${Ye(g)}`}});if(!w.ok&&w.status>=400&&w.status<600){let p;try{const h=await w.json();p=new Ae(h.message,w.status,h)}catch{p=new Ae(w.statusText,w.status)}throw p}let O;try{O=await w.json()}catch{O={}}return O}async function i(b){var I;const y=await r("/inbox-notifications",void 0,{limit:b==null?void 0:b.limit,since:(I=b==null?void 0:b.since)==null?void 0:I.toISOString()});return{threads:y.threads.map(g=>Ee(g)),inboxNotifications:y.inboxNotifications.map(g=>We(g)),deletedThreads:y.deletedThreads.map(g=>Ft(g)),deletedInboxNotifications:y.deletedInboxNotifications.map(g=>zt(g)),meta:{requestedAt:new Date(y.meta.requestedAt)}}}async function a(){const{count:b}=await r("/inbox-notifications/count");return b}async function c(){await r("/inbox-notifications/read",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({inboxNotificationIds:"all"})})}async function o(b){await r("/inbox-notifications/read",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({inboxNotificationIds:b})})}const f=new Ze(async b=>{const y=b.flat();return await o(y),y},{delay:ms});async function _(b){await f.get(b)}return{getInboxNotifications:i,getUnreadInboxNotificationsCount:a,markAllInboxNotificationsAsRead:c,markInboxNotificationAsRead:_}}var H=32,Q=126,ys=Q-H+1,Qe=et(0),Le=et(1),gs=Qe+et(-1);function et(t){const e=H+(t<0?ys+t:t);if(e<H||e>Q)throw new Error(`Invalid n value: ${t}`);return String.fromCharCode(e)}function q(t,e){return t!==void 0&&e!==void 0?ws(t,e):t!==void 0?bs(t):e!==void 0?vs(e):Le}function vs(t){const e=t.length-1;for(let n=0;n<=e;n++){const s=t.charCodeAt(n);if(!(s<=H))return n===e?s===H+1?t.substring(0,n)+gs:t.substring(0,n)+String.fromCharCode(s-1):t.substring(0,n+1)}return Le}function bs(t){for(let e=0;e<=t.length-1;e++){const n=t.charCodeAt(e);if(!(n>=Q))return t.substring(0,e)+String.fromCharCode(n+1)}return t+Le}function ws(t,e){if(t<e)return Je(t,e);if(t>e)return Je(e,t);throw new Error("Cannot compute value between two equal positions")}function Je(t,e){let n=0;const s=t.length,r=e.length;for(;;){const i=n<s?t.charCodeAt(n):H,a=n<r?e.charCodeAt(n):Q;if(i===a){n++;continue}if(a-i===1){const c=n+1;let o=t.substring(0,c);o.length<c&&(o+=Qe.repeat(c-o.length));const f=t.substring(c);return o+Je(f,"")}else return Is(t,n)+String.fromCharCode(a+i>>1)}}function Is(t,e){return e<t.length?t.substring(0,e):t+Qe.repeat(e-t.length)}var Ss=H+1;function ks(t){if(t==="")return!1;const e=t.length-1,n=t.charCodeAt(e);if(n<Ss||n>Q)return!1;for(let s=0;s<e;s++){const r=t.charCodeAt(s);if(r<H||r>Q)return!1}return!0}function Os(t){const e=[];for(let n=0;n<t.length;n++){const s=t.charCodeAt(n);e.push(s<H?H:s>Q?Q:s)}for(;e.length>0&&e[e.length-1]===H;)e.length--;return e.length>0?String.fromCharCode(...e):Le}function _e(t){return ks(t)?t:Os(t)}function Ts(t){return t.type===5&&t.id==="ACK"}function vt(t,e,n=_e(e)){return Object.freeze({type:"HasParent",node:t,key:e,pos:n})}var bt=Object.freeze({type:"NoParent"});function Es(t,e=_e(t)){return Object.freeze({type:"Orphaned",oldKey:t,oldPos:e})}var Ne=class{constructor(){this._parent=bt}_getParentKeyOrThrow(){switch(this.parent.type){case"HasParent":return this.parent.key;case"NoParent":throw new Error("Parent key is missing");case"Orphaned":return this.parent.oldKey;default:return W(this.parent,"Unknown state")}}get _parentPos(){switch(this.parent.type){case"HasParent":return this.parent.pos;case"NoParent":throw new Error("Parent key is missing");case"Orphaned":return this.parent.oldPos;default:return W(this.parent,"Unknown state")}}get _pool(){return this.__pool}get roomId(){return this.__pool?this.__pool.roomId:null}get _id(){return this.__id}get parent(){return this._parent}get _parentKey(){switch(this.parent.type){case"HasParent":return this.parent.key;case"NoParent":return null;case"Orphaned":return this.parent.oldKey;default:return W(this.parent,"Unknown state")}}_apply(t,e){switch(t.type){case 5:return this.parent.type==="HasParent"?this.parent.node._detachChild(this):{modified:!1}}return{modified:!1}}_setParentLink(t,e){switch(this.parent.type){case"HasParent":if(this.parent.node!==t)throw new Error("Cannot set parent: node already has a parent");this._parent=vt(t,e);return;case"Orphaned":case"NoParent":{this._parent=vt(t,e);return}default:return W(this.parent,"Unknown state")}}_attach(t,e){if(this.__id||this.__pool)throw new Error("Cannot attach node: already attached");e.addNode(t,this),this.__id=t,this.__pool=e}_detach(){switch(this.__pool&&this.__id&&this.__pool.deleteNode(this.__id),this.parent.type){case"HasParent":{this._parent=Es(this.parent.key,this.parent.pos);break}case"NoParent":{this._parent=bt;break}case"Orphaned":break;default:W(this.parent,"Unknown state")}this.__pool=void 0}invalidate(){(this._cachedImmutable!==void 0||this._cachedTreeNode!==void 0)&&(this._cachedImmutable=void 0,this._cachedTreeNode=void 0,this.parent.type==="HasParent"&&this.parent.node.invalidate())}toTreeNode(t){return(this._cachedTreeNode===void 0||this._cachedTreeNodeKey!==t)&&(this._cachedTreeNodeKey=t,this._cachedTreeNode=this._toTreeNode(t)),this._cachedTreeNode}toImmutable(){return this._cachedImmutable===void 0&&(this._cachedImmutable=this._toImmutable()),this._cachedImmutable}};function Cs(t){return t.type===0&&!As(t)}function As(t){return t.parentId!==void 0&&t.parentKey!==void 0}function Ue(t=7){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-",n=e.length;return Array.from({length:t},()=>e.charAt(Math.floor(Math.random()*n))).join("")}var se=class Bt extends Ne{constructor(e){super(),this._data=e}get data(){return this._data}static _deserialize([e,n],s,r){const i=new Bt(n.data);return i._attach(e,r),i}_toOps(e,n,s){if(this._id===void 0)throw new Error("Cannot serialize register if parentId or parentKey is undefined");return[{type:8,opId:s==null?void 0:s.generateOpId(),id:this._id,parentId:e,parentKey:n,data:this.data}]}_serialize(){if(this.parent.type!=="HasParent")throw new Error("Cannot serialize LiveRegister if parent is missing");return{type:3,parentId:S(this.parent.node._id,"Parent node expected to have ID"),parentKey:this.parent.key,data:this.data}}_attachChild(e){throw new Error("Method not implemented.")}_detachChild(e){throw new Error("Method not implemented.")}_apply(e,n){return super._apply(e,n)}_toTreeNode(e){return{type:"Json",id:this._id??Ue(),key:e,payload:this._data}}_toImmutable(){return this._data}clone(){return me(this.data)}};function Ps(t,e){const n=t._parentPos,s=e._parentPos;return n===s?0:n<s?-1:1}var re=class qe extends Ne{constructor(e=[]){super(),this._items=[],this._implicitlyDeletedItems=new WeakSet,this._unacknowledgedSets=new Map;let n;for(const s of e){const r=q(n),i=le(s);i._setParentLink(this,r),this._items.push(i),n=r}}static _deserialize([e],n,s){const r=new qe;r._attach(e,s);const i=n.get(e);if(i===void 0)return r;for(const[a,c]of i){const o=Jt([a,c],n,s);o._setParentLink(r,c.parentKey),r._insertAndSort(o)}return r}_toOps(e,n,s){if(this._id===void 0)throw new Error("Cannot serialize item is not attached");const r=[],i={id:this._id,opId:s==null?void 0:s.generateOpId(),type:2,parentId:e,parentKey:n};r.push(i);for(const a of this._items){const c=a._getParentKeyOrThrow(),o=Te(a._toOps(this._id,c,s),void 0),f=o[0].opId;f!==void 0&&this._unacknowledgedSets.set(c,f),r.push(...o)}return r}_insertAndSort(e){this._items.push(e),this._sortItems()}_sortItems(){this._items.sort(Ps),this.invalidate()}_indexOfPosition(e){return this._items.findIndex(n=>n._getParentKeyOrThrow()===e)}_attach(e,n){super._attach(e,n);for(const s of this._items)s._attach(n.generateId(),n)}_detach(){super._detach();for(const e of this._items)e._detach()}_applySetRemote(e){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");const{id:n,parentKey:s}=e,r=pe(e);r._attach(n,this._pool),r._setParentLink(this,s);const i=e.deletedId,a=this._indexOfPosition(s);if(a!==-1){const c=this._items[a];if(c._id===i)return c._detach(),this._items[a]=r,{modified:N(this,[ce(a,r)]),reverse:[]};{this._implicitlyDeletedItems.add(c),this._items[a]=r;const o=[ce(a,r)],f=this._detachItemAssociatedToSetOperation(e.deletedId);return f&&o.push(f),{modified:N(this,o),reverse:[]}}}else{const c=[],o=this._detachItemAssociatedToSetOperation(e.deletedId);return o&&c.push(o),this._insertAndSort(r),c.push(V(this._indexOfPosition(s),r)),{reverse:[],modified:N(this,c)}}}_applySetAck(e){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");const n=[],s=this._detachItemAssociatedToSetOperation(e.deletedId);s&&n.push(s);const r=this._unacknowledgedSets.get(e.parentKey);if(r!==void 0){if(r!==e.opId)return n.length===0?{modified:!1}:{modified:N(this,n),reverse:[]};this._unacknowledgedSets.delete(e.parentKey)}const i=this._indexOfPosition(e.parentKey),a=this._items.find(c=>c._id===e.id);if(a!==void 0){if(a._parentKey===e.parentKey)return{modified:n.length>0?N(this,n):!1,reverse:[]};i!==-1&&(this._implicitlyDeletedItems.add(this._items[i]),this._items.splice(i,1),n.push(Oe(i)));const c=this._items.indexOf(a);a._setParentLink(this,e.parentKey),this._sortItems();const o=this._items.indexOf(a);return o!==c&&n.push(te(c,o,a)),{modified:n.length>0?N(this,n):!1,reverse:[]}}else{const c=this._pool.getNode(e.id);if(c&&this._implicitlyDeletedItems.has(c)){c._setParentLink(this,e.parentKey),this._implicitlyDeletedItems.delete(c),this._insertAndSort(c);const o=this._items.indexOf(c);return{modified:N(this,[i===-1?V(o,c):ce(o,c),...n]),reverse:[]}}else{i!==-1&&this._items.splice(i,1);const{newItem:o,newIndex:f}=this._createAttachItemAndSort(e,e.parentKey);return{modified:N(this,[i===-1?V(f,o):ce(f,o),...n]),reverse:[]}}}}_detachItemAssociatedToSetOperation(e){if(e===void 0||this._pool===void 0)return null;const n=this._pool.getNode(e);if(n===void 0)return null;const s=this._detachChild(n);return s.modified===!1?null:s.modified.updates[0]}_applyRemoteInsert(e){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");const n=_e(e.parentKey),s=this._indexOfPosition(n);s!==-1&&this._shiftItemPosition(s,n);const{newItem:r,newIndex:i}=this._createAttachItemAndSort(e,n);return{modified:N(this,[V(i,r)]),reverse:[]}}_applyInsertAck(e){const n=this._items.find(i=>i._id===e.id),s=_e(e.parentKey),r=this._indexOfPosition(s);if(n){if(n._parentKey===s)return{modified:!1};{const i=this._items.indexOf(n);r!==-1&&this._shiftItemPosition(r,s),n._setParentLink(this,s),this._sortItems();const a=this._indexOfPosition(s);return a===i?{modified:!1}:{modified:N(this,[te(i,a,n)]),reverse:[]}}}else{const i=S(this._pool).getNode(e.id);if(i&&this._implicitlyDeletedItems.has(i)){i._setParentLink(this,s),this._implicitlyDeletedItems.delete(i),this._insertAndSort(i);const a=this._indexOfPosition(s);return{modified:N(this,[V(a,i)]),reverse:[]}}else{r!==-1&&this._shiftItemPosition(r,s);const{newItem:a,newIndex:c}=this._createAttachItemAndSort(e,s);return{modified:N(this,[V(c,a)]),reverse:[]}}}}_applyInsertUndoRedo(e){var o,f,_;const{id:n,parentKey:s}=e,r=pe(e);if(((o=this._pool)==null?void 0:o.getNode(n))!==void 0)return{modified:!1};r._attach(n,S(this._pool)),r._setParentLink(this,s);const i=this._indexOfPosition(s);let a=s;if(i!==-1){const b=(f=this._items[i])==null?void 0:f._parentPos,y=(_=this._items[i+1])==null?void 0:_._parentPos;a=q(b,y),r._setParentLink(this,a)}this._insertAndSort(r);const c=this._indexOfPosition(a);return{modified:N(this,[V(c,r)]),reverse:[{type:5,id:n}]}}_applySetUndoRedo(e){var c;const{id:n,parentKey:s}=e,r=pe(e);if(((c=this._pool)==null?void 0:c.getNode(n))!==void 0)return{modified:!1};this._unacknowledgedSets.set(s,S(e.opId));const i=this._indexOfPosition(s);r._attach(n,S(this._pool)),r._setParentLink(this,s);const a=s;if(i!==-1){const o=this._items[i];o._detach(),this._items[i]=r;const f=Te(o._toOps(S(this._id),s,this._pool),e.id),_=[ce(i,r)],b=this._detachItemAssociatedToSetOperation(e.deletedId);return b&&_.push(b),{modified:N(this,_),reverse:f}}else{this._insertAndSort(r),this._detachItemAssociatedToSetOperation(e.deletedId);const o=this._indexOfPosition(a);return{reverse:[{type:5,id:n}],modified:N(this,[V(o,r)])}}}_attachChild(e,n){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");let s;return e.intent==="set"?n===1?s=this._applySetRemote(e):n===2?s=this._applySetAck(e):s=this._applySetUndoRedo(e):n===1?s=this._applyRemoteInsert(e):n===2?s=this._applyInsertAck(e):s=this._applyInsertUndoRedo(e),s.modified!==!1&&this.invalidate(),s}_detachChild(e){if(e){const n=S(e._parentKey),s=e._toOps(S(this._id),n,this._pool),r=this._items.indexOf(e);return r===-1?{modified:!1}:(this._items.splice(r,1),this.invalidate(),e._detach(),{modified:N(this,[Oe(r)]),reverse:s})}return{modified:!1}}_applySetChildKeyRemote(e,n){var i;if(this._implicitlyDeletedItems.has(n)){this._implicitlyDeletedItems.delete(n),n._setParentLink(this,e),this._insertAndSort(n);const a=this._items.indexOf(n);return{modified:N(this,[V(a,n)]),reverse:[]}}const s=n._parentKey;if(e===s)return{modified:!1};const r=this._indexOfPosition(e);if(r===-1){const a=this._items.indexOf(n);n._setParentLink(this,e),this._sortItems();const c=this._items.indexOf(n);return c===a?{modified:!1}:{modified:N(this,[te(a,c,n)]),reverse:[]}}else{this._items[r]._setParentLink(this,q(e,(i=this._items[r+1])==null?void 0:i._parentPos));const a=this._items.indexOf(n);n._setParentLink(this,e),this._sortItems();const c=this._items.indexOf(n);return c===a?{modified:!1}:{modified:N(this,[te(a,c,n)]),reverse:[]}}}_applySetChildKeyAck(e,n){var r,i;const s=S(n._parentKey);if(this._implicitlyDeletedItems.has(n)){const a=this._indexOfPosition(e);return this._implicitlyDeletedItems.delete(n),a!==-1&&this._items[a]._setParentLink(this,q(e,(r=this._items[a+1])==null?void 0:r._parentPos)),n._setParentLink(this,e),this._insertAndSort(n),{modified:!1}}else{if(e===s)return{modified:!1};const a=this._items.indexOf(n),c=this._indexOfPosition(e);c!==-1&&this._items[c]._setParentLink(this,q(e,(i=this._items[c+1])==null?void 0:i._parentPos)),n._setParentLink(this,e),this._sortItems();const o=this._items.indexOf(n);return a===o?{modified:!1}:{modified:N(this,[te(a,o,n)]),reverse:[]}}}_applySetChildKeyUndoRedo(e,n){var c;const s=S(n._parentKey),r=this._items.indexOf(n),i=this._indexOfPosition(e);i!==-1&&this._items[i]._setParentLink(this,q(e,(c=this._items[i+1])==null?void 0:c._parentPos)),n._setParentLink(this,e),this._sortItems();const a=this._items.indexOf(n);return r===a?{modified:!1}:{modified:N(this,[te(r,a,n)]),reverse:[{type:1,id:S(n._id),parentKey:s}]}}_setChildKey(e,n,s){return s===1?this._applySetChildKeyRemote(e,n):s===2?this._applySetChildKeyAck(e,n):this._applySetChildKeyUndoRedo(e,n)}_apply(e,n){return super._apply(e,n)}_serialize(){if(this.parent.type!=="HasParent")throw new Error("Cannot serialize LiveList if parent is missing");return{type:1,parentId:S(this.parent.node._id,"Parent node expected to have ID"),parentKey:this.parent.key}}get length(){return this._items.length}push(e){var n;return(n=this._pool)==null||n.assertStorageIsWritable(),this.insert(e,this.length)}insert(e,n){var c;if((c=this._pool)==null||c.assertStorageIsWritable(),n<0||n>this._items.length)throw new Error(`Cannot insert list item at index "${n}". index should be between 0 and ${this._items.length}`);const s=this._items[n-1]?this._items[n-1]._parentPos:void 0,r=this._items[n]?this._items[n]._parentPos:void 0,i=q(s,r),a=le(e);if(a._setParentLink(this,i),this._insertAndSort(a),this._pool&&this._id){const o=this._pool.generateId();a._attach(o,this._pool),this._pool.dispatch(a._toOps(this._id,i,this._pool),[{type:5,id:o}],new Map([[this._id,N(this,[V(n,a)])]]))}}move(e,n){var o;if((o=this._pool)==null||o.assertStorageIsWritable(),n<0)throw new Error("targetIndex cannot be less than 0");if(n>=this._items.length)throw new Error("targetIndex cannot be greater or equal than the list length");if(e<0)throw new Error("index cannot be less than 0");if(e>=this._items.length)throw new Error("index cannot be greater or equal than the list length");let s=null,r=null;e<n?(r=n===this._items.length-1?void 0:this._items[n+1]._parentPos,s=this._items[n]._parentPos):(r=this._items[n]._parentPos,s=n===0?void 0:this._items[n-1]._parentPos);const i=q(s,r),a=this._items[e],c=a._getParentKeyOrThrow();if(a._setParentLink(this,i),this._sortItems(),this._pool&&this._id){const f=new Map([[this._id,N(this,[te(e,n,a)])]]);this._pool.dispatch([{type:1,id:S(a._id),opId:this._pool.generateOpId(),parentKey:i}],[{type:1,id:S(a._id),parentKey:c}],f)}}delete(e){var s;if((s=this._pool)==null||s.assertStorageIsWritable(),e<0||e>=this._items.length)throw new Error(`Cannot delete list item at index "${e}". index should be between 0 and ${this._items.length-1}`);const n=this._items[e];if(n._detach(),this._items.splice(e,1),this.invalidate(),this._pool){const r=n._id;if(r){const i=new Map;i.set(S(this._id),N(this,[Oe(e)])),this._pool.dispatch([{id:r,opId:this._pool.generateOpId(),type:5}],n._toOps(S(this._id),n._getParentKeyOrThrow()),i)}}}clear(){var e;if((e=this._pool)==null||e.assertStorageIsWritable(),this._pool){const n=[],s=[],r=[];for(const a of this._items){a._detach();const c=a._id;c&&(n.push({type:5,id:c,opId:this._pool.generateOpId()}),s.push(...a._toOps(S(this._id),a._getParentKeyOrThrow())),r.push(Oe(0)))}this._items=[],this.invalidate();const i=new Map;i.set(S(this._id),N(this,r)),this._pool.dispatch(n,s,i)}else{for(const n of this._items)n._detach();this._items=[],this.invalidate()}}set(e,n){var c;if((c=this._pool)==null||c.assertStorageIsWritable(),e<0||e>=this._items.length)throw new Error(`Cannot set list item at index "${e}". index should be between 0 and ${this._items.length-1}`);const s=this._items[e],r=s._getParentKeyOrThrow(),i=s._id;s._detach();const a=le(n);if(a._setParentLink(this,r),this._items[e]=a,this.invalidate(),this._pool&&this._id){const o=this._pool.generateId();a._attach(o,this._pool);const f=new Map;f.set(this._id,N(this,[ce(e,a)]));const _=Te(a._toOps(this._id,r,this._pool),i);this._unacknowledgedSets.set(r,S(_[0].opId));const b=Te(s._toOps(this._id,r,void 0),o);this._pool.dispatch(_,b,f)}}toArray(){return this._items.map(e=>ne(e))}every(e){return this.toArray().every(e)}filter(e){return this.toArray().filter(e)}find(e){return this.toArray().find(e)}findIndex(e){return this.toArray().findIndex(e)}forEach(e){return this.toArray().forEach(e)}get(e){if(!(e<0||e>=this._items.length))return ne(this._items[e])}indexOf(e,n){return this.toArray().indexOf(e,n)}lastIndexOf(e,n){return this.toArray().lastIndexOf(e,n)}map(e){return this._items.map((n,s)=>e(ne(n),s))}some(e){return this.toArray().some(e)}[Symbol.iterator](){return new Ls(this._items)}_createAttachItemAndSort(e,n){const s=pe(e);s._attach(e.id,S(this._pool)),s._setParentLink(this,n),this._insertAndSort(s);const r=this._indexOfPosition(n);return{newItem:s,newIndex:r}}_shiftItemPosition(e,n){var r;const s=q(n,this._items.length>e+1?(r=this._items[e+1])==null?void 0:r._parentPos:void 0);this._items[e]._setParentLink(this,s)}_toTreeNode(e){return{type:"LiveList",id:this._id??Ue(),key:e,payload:this._items.map((n,s)=>n.toTreeNode(s.toString()))}}toImmutable(){return super.toImmutable()}_toImmutable(){return this._items.map(n=>n.toImmutable())}clone(){return new qe(this._items.map(e=>e.clone()))}},Ls=class{constructor(t){this._innerIterator=t[Symbol.iterator]()}[Symbol.iterator](){return this}next(){const t=this._innerIterator.next();return t.done?{done:!0,value:void 0}:{value:ne(t.value)}}};function N(t,e){return{node:t,type:"LiveList",updates:e}}function ce(t,e){return{index:t,type:"set",item:e instanceof se?e.data:e}}function Oe(t){return{index:t,type:"delete"}}function V(t,e){return{index:t,type:"insert",item:e instanceof se?e.data:e}}function te(t,e,n){return{index:e,type:"move",previousIndex:t,item:n instanceof se?n.data:n}}function Te(t,e){return t.map((n,s)=>s===0?{...n,intent:"set",deletedId:e}:n)}var G=t=>t,ie=class Ge extends Ne{constructor(e){if(super(),this.unacknowledgedSet=new Map,e){const n=[];for(const[s,r]of e){const i=le(r);i._setParentLink(this,s),n.push([s,i])}this._map=new Map(n)}else this._map=new Map}_toOps(e,n,s){if(this._id===void 0)throw new Error("Cannot serialize item is not attached");const r=[],i={id:this._id,opId:s==null?void 0:s.generateOpId(),type:7,parentId:e,parentKey:n};r.push(i);for(const[a,c]of this._map)r.push(...c._toOps(this._id,a,s));return r}static _deserialize([e,n],s,r){const i=new Ge;i._attach(e,r);const a=s.get(e);if(a===void 0)return i;for(const[c,o]of a){const f=Jt([c,o],s,r);f._setParentLink(i,o.parentKey),i._map.set(o.parentKey,f),i.invalidate()}return i}_attach(e,n){super._attach(e,n);for(const[s,r]of this._map)x(r)&&r._attach(n.generateId(),n)}_attachChild(e,n){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");const{id:s,parentKey:r,opId:i}=e,a=r,c=pe(e);if(this._pool.getNode(s)!==void 0)return{modified:!1};if(n===2){const _=this.unacknowledgedSet.get(a);if(_===i)return this.unacknowledgedSet.delete(a),{modified:!1};if(_!==void 0)return{modified:!1}}else n===1&&this.unacknowledgedSet.delete(a);const o=this._map.get(a);let f;if(o){const _=S(this._id);f=o._toOps(_,a),o._detach()}else f=[{type:5,id:s}];return c._setParentLink(this,a),c._attach(s,this._pool),this._map.set(a,c),this.invalidate(),{modified:{node:this,type:"LiveMap",updates:{[a]:{type:"update"}}},reverse:f}}_detach(){super._detach();for(const e of this._map.values())e._detach()}_detachChild(e){const n=S(this._id),s=S(e._parentKey),r=e._toOps(n,s,this._pool);for(const[a,c]of this._map)c===e&&(this._map.delete(a),this.invalidate());return e._detach(),{modified:{node:this,type:"LiveMap",updates:{[s]:{type:"delete"}}},reverse:r}}_serialize(){if(this.parent.type!=="HasParent")throw new Error("Cannot serialize LiveMap if parent is missing");return{type:2,parentId:S(this.parent.node._id,"Parent node expected to have ID"),parentKey:this.parent.key}}get(e){const n=this._map.get(e);if(n!==void 0)return ne(n)}set(e,n){var i;(i=this._pool)==null||i.assertStorageIsWritable();const s=this._map.get(e);s&&s._detach();const r=le(n);if(r._setParentLink(this,e),this._map.set(e,r),this.invalidate(),this._pool&&this._id){const a=this._pool.generateId();r._attach(a,this._pool);const c=new Map;c.set(this._id,{node:this,type:"LiveMap",updates:{[e]:{type:"update"}}});const o=r._toOps(this._id,e,this._pool);this.unacknowledgedSet.set(e,S(o[0].opId)),this._pool.dispatch(r._toOps(this._id,e,this._pool),s?s._toOps(this._id,e):[{type:5,id:a}],c)}}get size(){return this._map.size}has(e){return this._map.has(e)}delete(e){var s;(s=this._pool)==null||s.assertStorageIsWritable();const n=this._map.get(e);if(n===void 0)return!1;if(n._detach(),this._map.delete(e),this.invalidate(),this._pool&&n._id){const r=S(this._id),i=new Map;i.set(r,{node:this,type:"LiveMap",updates:{[e]:{type:"delete"}}}),this._pool.dispatch([{type:5,id:n._id,opId:this._pool.generateOpId()}],n._toOps(r,e),i)}return!0}entries(){const e=this._map.entries();return{[Symbol.iterator](){return this},next(){const n=e.next();if(n.done)return{done:!0,value:void 0};const r=n.value[0],i=ne(n.value[1]);return{value:[r,i]}}}}[Symbol.iterator](){return this.entries()}keys(){return this._map.keys()}values(){const e=this._map.values();return{[Symbol.iterator](){return this},next(){const n=e.next();return n.done?{done:!0,value:void 0}:{value:ne(n.value)}}}}forEach(e){for(const n of this)e(n[1],n[0],this)}_toTreeNode(e){return{type:"LiveMap",id:this._id??Ue(),key:e,payload:Array.from(this._map.entries()).map(([n,s])=>s.toTreeNode(n))}}toImmutable(){return super.toImmutable()}_toImmutable(){const e=new Map;for(const[n,s]of this._map)e.set(n,s.toImmutable());return G(e)}clone(){return new Ge(Array.from(this._map).map(([e,n])=>[e,n.clone()]))}},ee=class he extends Ne{constructor(e={}){super(),this._propToLastUpdate=new Map;const n=Pe(e);for(const s of Object.keys(n)){const r=n[s];x(r)&&r._setParentLink(this,s)}this._map=new Map(Object.entries(n))}static _buildRootAndParentToChildren(e){const n=new Map;let s=null;for(const[r,i]of e)if(Cs(i))s=[r,i];else{const a=[r,i],c=n.get(i.parentId);c!==void 0?c.push(a):n.set(i.parentId,[a])}if(s===null)throw new Error("Root can't be null");return[s,n]}static _fromItems(e,n){const[s,r]=he._buildRootAndParentToChildren(e);return he._deserialize(s,r,n)}_toOps(e,n,s){if(this._id===void 0)throw new Error("Cannot serialize item is not attached");const r=s==null?void 0:s.generateOpId(),i=[],a={type:4,id:this._id,opId:r,parentId:e,parentKey:n,data:{}};i.push(a);for(const[c,o]of this._map)x(o)?i.push(...o._toOps(this._id,c,s)):a.data[c]=o;return i}static _deserialize([e,n],s,r){const i=new he(n.data);return i._attach(e,r),this._deserializeChildren(i,s,r)}static _deserializeChildren(e,n,s){const r=n.get(S(e._id));if(r===void 0)return e;for(const[i,a]of r){const c=Ns([i,a],n,s);ue(c)&&c._setParentLink(e,a.parentKey),e._map.set(a.parentKey,c),e.invalidate()}return e}_attach(e,n){super._attach(e,n);for(const[s,r]of this._map)x(r)&&r._attach(n.generateId(),n)}_attachChild(e,n){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");const{id:s,opId:r,parentKey:i}=e,a=Vt(e);if(this._pool.getNode(s)!==void 0)return this._propToLastUpdate.get(i)===r&&this._propToLastUpdate.delete(i),{modified:!1};if(n===0)this._propToLastUpdate.set(i,S(r));else if(this._propToLastUpdate.get(i)!==void 0)return this._propToLastUpdate.get(i)===r?(this._propToLastUpdate.delete(i),{modified:!1}):{modified:!1};const c=S(this._id),o=this._map.get(i);let f;return x(o)?(f=o._toOps(c,i),o._detach()):o===void 0?f=[{type:6,id:c,key:i}]:f=[{type:3,id:c,data:{[i]:o}}],this._map.set(i,a),this.invalidate(),ue(a)&&(a._setParentLink(this,i),a._attach(s,this._pool)),{reverse:f,modified:{node:this,type:"LiveObject",updates:{[i]:{type:"update"}}}}}_detachChild(e){if(e){const n=S(this._id),s=S(e._parentKey),r=e._toOps(n,s,this._pool);for(const[a,c]of this._map)c===e&&(this._map.delete(a),this.invalidate());return e._detach(),{modified:{node:this,type:"LiveObject",updates:{[s]:{type:"delete"}}},reverse:r}}return{modified:!1}}_detach(){super._detach();for(const e of this._map.values())x(e)&&e._detach()}_apply(e,n){return e.type===3?this._applyUpdate(e,n):e.type===6?this._applyDeleteObjectKey(e,n):super._apply(e,n)}_serialize(){const e={};for(const[n,s]of this._map)x(s)||(e[n]=s);return this.parent.type==="HasParent"&&this.parent.node._id?{type:0,parentId:this.parent.node._id,parentKey:this.parent.key,data:e}:{type:0,data:e}}_applyUpdate(e,n){let s=!1;const r=S(this._id),i=[],a={type:3,id:r,data:{}};for(const o in e.data){const f=this._map.get(o);x(f)?(i.push(...f._toOps(r,o)),f._detach()):f!==void 0?a.data[o]=f:f===void 0&&i.push({type:6,id:r,key:o})}const c={};for(const o in e.data){const f=e.data[o];if(f===void 0)continue;if(n)this._propToLastUpdate.set(o,S(e.opId));else if(this._propToLastUpdate.get(o)===void 0)s=!0;else if(this._propToLastUpdate.get(o)===e.opId){this._propToLastUpdate.delete(o);continue}else continue;const _=this._map.get(o);x(_)&&_._detach(),s=!0,c[o]={type:"update"},this._map.set(o,f),this.invalidate()}return Object.keys(a.data).length!==0&&i.unshift(a),s?{modified:{node:this,type:"LiveObject",updates:c},reverse:i}:{modified:!1}}_applyDeleteObjectKey(e,n){const s=e.key;if(this._map.has(s)===!1)return{modified:!1};if(!n&&this._propToLastUpdate.get(s)!==void 0)return{modified:!1};const r=this._map.get(s),i=S(this._id);let a=[];return x(r)?(a=r._toOps(i,e.key),r._detach()):r!==void 0&&(a=[{type:3,id:i,data:{[s]:r}}]),this._map.delete(s),this.invalidate(),{modified:{node:this,type:"LiveObject",updates:{[e.key]:{type:"delete"}}},reverse:a}}toObject(){return Object.fromEntries(this._map)}set(e,n){var s;(s=this._pool)==null||s.assertStorageIsWritable(),this.update({[e]:n})}get(e){return this._map.get(e)}delete(e){var a;(a=this._pool)==null||a.assertStorageIsWritable();const n=e,s=this._map.get(n);if(s===void 0)return;if(this._pool===void 0||this._id===void 0){x(s)&&s._detach(),this._map.delete(n),this.invalidate();return}let r;x(s)?(s._detach(),r=s._toOps(this._id,n)):r=[{type:3,data:{[n]:s},id:this._id}],this._map.delete(n),this.invalidate();const i=new Map;i.set(this._id,{node:this,type:"LiveObject",updates:{[e]:{type:"delete"}}}),this._pool.dispatch([{type:6,key:n,id:this._id,opId:this._pool.generateOpId()}],r,i)}update(e){var f;if((f=this._pool)==null||f.assertStorageIsWritable(),this._pool===void 0||this._id===void 0){for(const _ in e){const b=e[_];if(b===void 0)continue;const y=this._map.get(_);x(y)&&y._detach(),x(b)&&b._setParentLink(this,_),this._map.set(_,b),this.invalidate()}return}const n=[],s=[],r=this._pool.generateOpId(),i={},a={id:this._id,type:3,data:{}},c={};for(const _ in e){const b=e[_];if(b===void 0)continue;const y=this._map.get(_);if(x(y)?(s.push(...y._toOps(this._id,_)),y._detach()):y===void 0?s.push({type:6,id:this._id,key:_}):a.data[_]=y,x(b)){b._setParentLink(this,_),b._attach(this._pool.generateId(),this._pool);const I=b._toOps(this._id,_,this._pool),g=I.find(v=>v.parentId===this._id);g&&this._propToLastUpdate.set(_,S(g.opId)),n.push(...I)}else i[_]=b,this._propToLastUpdate.set(_,r);this._map.set(_,b),this.invalidate(),c[_]={type:"update"}}Object.keys(a.data).length!==0&&s.unshift(a),Object.keys(i).length!==0&&n.unshift({opId:r,id:this._id,type:3,data:i});const o=new Map;o.set(this._id,{node:this,type:"LiveObject",updates:c}),this._pool.dispatch(n,s,o)}toImmutable(){return super.toImmutable()}toTreeNode(e){return super.toTreeNode(e)}_toTreeNode(e){const n=this._id??Ue();return{type:"LiveObject",id:n,key:e,payload:Array.from(this._map.entries()).map(([s,r])=>x(r)?r.toTreeNode(s):{type:"Json",id:`${n}:${s}`,key:s,payload:r})}}_toImmutable(){const e={};for(const[n,s]of this._map)e[n]=ue(s)?s.toImmutable():s;return e}clone(){return new he(Object.fromEntries(Array.from(this._map).map(([e,n])=>[e,ue(n)?n.clone():me(n)])))}};function pe(t){return le(Vt(t))}function Vt(t){switch(t.type){case 8:return t.data;case 4:return new ee(t.data);case 7:return new ie;case 2:return new re;default:return W(t,"Unknown creation Op")}}function Wt(t,e){return t===e?!0:t.parent.type==="HasParent"?Wt(t.parent.node,e):!1}function Jt([t,e],n,s){switch(e.type){case 0:return ee._deserialize([t,e],n,s);case 1:return re._deserialize([t,e],n,s);case 2:return ie._deserialize([t,e],n,s);case 3:return se._deserialize([t,e],n,s);default:throw new Error("Unexpected CRDT type")}}function Ns([t,e],n,s){switch(e.type){case 0:return ee._deserialize([t,e],n,s);case 1:return re._deserialize([t,e],n,s);case 2:return ie._deserialize([t,e],n,s);case 3:return e.data;default:throw new Error("Unexpected CRDT type")}}function ue(t){return qt(t)||Us(t)||xs(t)}function x(t){return ue(t)||Ds(t)}function qt(t){return t instanceof re}function Us(t){return t instanceof ie}function xs(t){return t instanceof ee}function Ds(t){return t instanceof se}function Rs(t){return t===void 0?void 0:ue(t)?t.clone():me(t)}function ne(t){return t instanceof se?t.data:t instanceof re||t instanceof ie||t instanceof ee?t:W(t,"Unknown AbstractCrdt")}function le(t){return t instanceof ee||t instanceof ie||t instanceof re?t:new se(t)}function Ms(t,e){const n=[];return t.forEach((s,r)=>{e.get(r)||n.push({type:5,id:r})}),e.forEach((s,r)=>{const i=t.get(r);if(i)s.type===0&&(i.type!==0||JSON.stringify(s.data)!==JSON.stringify(i.data))&&n.push({type:3,id:r,data:s.data}),s.parentKey!==i.parentKey&&n.push({type:1,id:r,parentKey:S(s.parentKey,"Parent key must not be missing")});else switch(s.type){case 3:n.push({type:8,id:r,parentId:s.parentId,parentKey:s.parentKey,data:s.data});break;case 1:n.push({type:2,id:r,parentId:s.parentId,parentKey:s.parentKey});break;case 0:if(s.parentId===void 0||s.parentKey===void 0)throw new Error("Internal error. Cannot serialize storage root into an operation");n.push({type:4,id:r,parentId:s.parentId,parentKey:s.parentKey,data:s.data});break;case 2:n.push({type:7,id:r,parentId:s.parentId,parentKey:s.parentKey});break}}),n}function Ks(t,e){const n=t.updates;for(const[s,r]of Ut(e.updates))n[s]=r;return{...e,updates:n}}function $s(t,e){const n=t.updates;for(const[s,r]of Ut(e.updates))n[s]=r;return{...e,updates:n}}function js(t,e){const n=t.updates;return{...e,updates:n.concat(e.updates)}}function je(t,e){return t===void 0?e:t.type==="LiveObject"&&e.type==="LiveObject"?Ks(t,e):t.type==="LiveMap"&&e.type==="LiveMap"?$s(t,e):t.type==="LiveList"&&e.type==="LiveList"?js(t,e):e}function Fs(t){return t===null||typeof t=="string"||typeof t=="number"||typeof t=="boolean"}function Gt(t){return Array.isArray(t)}function zs(t){return!Fs(t)&&!Gt(t)}function Yt(t,e){let n=!1;const s={...t};return Object.keys(e).forEach(r=>{const i=r,a=e[i];s[i]!==a&&(a===void 0?delete s[i]:s[i]=a,n=!0)}),n?s:t}var xe=class{constructor(){this._ev=P()}get didInvalidate(){return this._ev.observable}invalidate(){this._cache!==void 0&&(this._cache=void 0,this._ev.notify())}get current(){return this._cache??(this._cache=this._toImmutable())}};function Hs(t,e){const{connectionId:n,id:s,info:r}=t,i=He(t.scopes);return G(Pe({connectionId:n,id:s,info:r,canWrite:i,canComment:$t(t.scopes),isReadOnly:!i,presence:e}))}var Bs=class extends xe{constructor(){super(),this._connections=new Map,this._presences=new Map,this._users=new Map}connectionIds(){return this._connections.keys()}_toImmutable(){return ze(Array.from(this._presences.keys()).map(e=>this.getUser(Number(e))))}clearOthers(){this._connections=new Map,this._presences=new Map,this._users=new Map,this.invalidate()}_getUser(t){const e=this._connections.get(t),n=this._presences.get(t);if(e!==void 0&&n!==void 0)return Hs(e,n)}getUser(t){const e=this._users.get(t);if(e)return e;const n=this._getUser(t);if(n)return this._users.set(t,n),n}_invalidateUser(t){this._users.has(t)&&this._users.delete(t),this.invalidate()}setConnection(t,e,n,s){this._connections.set(t,G({connectionId:t,id:e,info:n,scopes:s})),this._presences.has(t)&&this._invalidateUser(t)}removeConnection(t){this._connections.delete(t),this._presences.delete(t),this._invalidateUser(t)}setOther(t,e){this._presences.set(t,G(Pe(e))),this._connections.has(t)&&this._invalidateUser(t)}patchOther(t,e){const n=this._presences.get(t);if(n===void 0)return;const s=Yt(n,e);n!==s&&(this._presences.set(t,G(s)),this._invalidateUser(t))}},Vs=class extends xe{constructor(t){super(),this._data=G(Pe(t))}_toImmutable(){return this._data}patch(t){const e=this._data,n=Yt(e,t);e!==n&&(this._data=G(n),this.invalidate())}},wt=class extends xe{constructor(t){super(),this._value=G(t)}_toImmutable(){return this._value}set(t){this._value=G(t),this.invalidate()}},Fe=class extends xe{constructor(...t){super();const e=t.pop(),n=t;this._refs=n,this._refs.forEach(s=>{s.didInvalidate.subscribe(()=>this.invalidate())}),this._transform=e}_toImmutable(){return this._transform(...this._refs.map(t=>t.current))}},Ws=1024*1024-1024;function Js(t){let e=0;return()=>`${t}:${e++}`}function It(t,e){return{type:"User",id:`${e.connectionId}`,key:t,payload:e}}function qs(){const t=typeof document<"u"?document:void 0,e={current:null};function n(){(t==null?void 0:t.visibilityState)==="hidden"?e.current=e.current??Date.now():e.current=null}return t==null||t.addEventListener("visibilitychange",n),[e,()=>{t==null||t.removeEventListener("visibilitychange",n)}]}var St=class extends Error{constructor(t,e,n){super(t),this.message=t,this.status=e,this.details=n}};function Gs(t,e,n){async function s(g,v,w){const O=await e();return n(t,g,O,w,v)}async function r(g,v,w){const O=await s(g,w,v);if(!O.ok&&O.status>=400&&O.status<600){let h;try{const A=await O.json();h=new St(A.message,O.status,A)}catch{h=new St(O.statusText,O.status)}throw h}let p;try{p=await O.json()}catch{p={}}return p}async function i(g){var w,O;const v=await s("/threads/search",{since:(w=g==null?void 0:g.since)==null?void 0:w.toISOString()},{body:JSON.stringify({...((O=g==null?void 0:g.query)==null?void 0:O.metadata)&&{metadata:g.query.metadata}}),headers:{"Content-Type":"application/json"},method:"POST"});if(v.ok){const p=await v.json();return{threads:p.data.map(h=>Ee(h)),inboxNotifications:p.inboxNotifications.map(h=>We(h)),deletedThreads:p.deletedThreads.map(h=>Ft(h)),deletedInboxNotifications:p.deletedInboxNotifications.map(h=>zt(h)),meta:{requestedAt:new Date(p.meta.requestedAt)}}}else{if(v.status===404)return{threads:[],inboxNotifications:[],deletedThreads:[],deletedInboxNotifications:[],meta:{requestedAt:new Date}};throw new Error("There was an error while getting threads.")}}async function a({threadId:g}){const v=await s(`/thread-with-notification/${g}`);if(v.ok){const w=await v.json();return{thread:Ee(w.thread),inboxNotification:w.inboxNotification?We(w.inboxNotification):void 0}}else{if(v.status===404)return;throw new Error(`There was an error while getting thread ${g}.`)}}async function c({metadata:g,body:v,commentId:w,threadId:O}){const p=await r("/threads",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:O,comment:{id:w,body:v},metadata:g})});return Ee(p)}async function o({metadata:g,threadId:v}){return await r(`/threads/${encodeURIComponent(v)}/metadata`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(g)})}async function f({threadId:g,commentId:v,body:w}){const O=await r(`/threads/${encodeURIComponent(g)}/comments`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:v,body:w})});return Ve(O)}async function _({threadId:g,commentId:v,body:w}){const O=await r(`/threads/${encodeURIComponent(g)}/comments/${encodeURIComponent(v)}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({body:w})});return Ve(O)}async function b({threadId:g,commentId:v}){await r(`/threads/${encodeURIComponent(g)}/comments/${encodeURIComponent(v)}`,{method:"DELETE"})}async function y({threadId:g,commentId:v,emoji:w}){const O=await r(`/threads/${encodeURIComponent(g)}/comments/${encodeURIComponent(v)}/reactions`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({emoji:w})});return hs(O)}async function I({threadId:g,commentId:v,emoji:w}){await r(`/threads/${encodeURIComponent(g)}/comments/${encodeURIComponent(v)}/reactions/${encodeURIComponent(w)}`,{method:"DELETE"})}return{getThreads:i,getThread:a,createThread:c,editThreadMetadata:o,createComment:f,editComment:_,deleteComment:b,addReaction:y,removeReaction:I}}var Ys=50;function Xs(t,e){const n=typeof t.initialPresence=="function"?t.initialPresence(e.roomId):t.initialPresence,s=typeof t.initialStorage=="function"?t.initialStorage(e.roomId):t.initialStorage,[r,i]=qs(),a={...e.delegates,canZombie(){return e.backgroundKeepAliveTimeout!==void 0&&r.current!==null&&Date.now()>r.current+e.backgroundKeepAliveTimeout&&ve()!=="synchronizing"}},c=new ss(a,e.enableDebugLogging),o={buffer:{flushTimerID:void 0,lastFlushedAt:0,presenceUpdates:{type:"full",data:n},messages:[],storageOperations:[]},staticSessionInfo:new wt(null),dynamicSessionInfo:new wt(null),myPresence:new Vs(n),others:new Bs,initialStorage:s,idFactory:null,clock:0,opClock:0,nodes:new Map,root:void 0,undoStack:[],redoStack:[],pausedHistory:null,activeBatch:null,unacknowledgedOps:new Map,opStackTraces:void 0},f=d=>d(),_=e.unstable_batchedUpdates??f;let b;function y(d){const u=c.authValue;if(u!==null){const l=Ye(u);if(l!==b)if(b=l,u.type==="secret"){const m=u.token.parsed;o.staticSessionInfo.set({userId:m.k==="sec-legacy"?m.id:m.uid,userInfo:m.k==="sec-legacy"?m.info:m.ui})}else o.staticSessionInfo.set({userId:void 0,userInfo:void 0})}_(()=>{h.status.notify(d),B(f)})}let I,g=!1;function v(d){d==="reconnecting"?I=setTimeout(()=>{_(()=>{h.lostConnection.notify("lost"),g=!0,o.others.clearOthers(),j({others:[{type:"reset"}]},f)})},e.lostConnectionTimeout):(clearTimeout(I),g&&(_(d==="disconnected"?()=>{h.lostConnection.notify("failed")}:()=>{h.lostConnection.notify("restored")}),g=!1))}function w(){o.buffer.presenceUpdates={type:"full",data:{...o.myPresence.current}},fe!==null&&at({flush:!1}),F()}function O(){clearTimeout(o.buffer.flushTimerID)}c.events.onMessage.subscribe(an),c.events.statusDidChange.subscribe(y),c.events.statusDidChange.subscribe(v),c.events.didConnect.subscribe(w),c.events.didDisconnect.subscribe(O),c.events.onLiveblocksError.subscribe(d=>{_(()=>{h.error.notify(d)})});const p={roomId:e.roomId,getNode:d=>o.nodes.get(d),addNode:(d,u)=>void o.nodes.set(d,u),deleteNode:d=>void o.nodes.delete(d),generateId:()=>`${De()}:${o.clock++}`,generateOpId:()=>`${De()}:${o.opClock++}`,dispatch(d,u,l){const m=o.activeBatch;if(m){for(const k of d)m.ops.push(k);for(const[k,T]of l)m.updates.storageUpdates.set(k,je(m.updates.storageUpdates.get(k),T));m.reverseOps.unshift(...u)}else _(()=>{$(u,f),o.redoStack.length=0,it(d),j({storageUpdates:l},f)})},assertStorageIsWritable:()=>{var l;const d=(l=o.dynamicSessionInfo.current)==null?void 0:l.scopes;if(d===void 0)return;if(!He(d))throw new Error("Cannot write to storage with a read only user, please ensure the user has write permissions")}},h={connection:P(),status:P(),lostConnection:P(),customEvent:P(),self:P(),myPresence:P(),others:P(),error:P(),storage:P(),history:P(),storageDidLoad:P(),storageStatus:P(),ydoc:P(),comments:P()};async function A(d,u,l,m,k){var R;const T=Ht(e.baseUrl,`/v2/c/rooms/${encodeURIComponent(d)}${u}`,k);return await(((R=e.polyfills)==null?void 0:R.fetch)||fetch)(T,{...m,headers:{...m==null?void 0:m.headers,Authorization:`Bearer ${Ye(l)}`}})}async function z(d,u){return A(u,"/storage",d,{method:"GET",headers:{"Content-Type":"application/json"}})}async function Y(d,u){if(!c.authValue)throw new Error("Not authorized");return A(e.roomId,d,c.authValue,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(u)})}function K(d){var m;const u=JSON.stringify(d),l=(m=o.dynamicSessionInfo.current)==null?void 0:m.nonce;if(e.unstable_fallbackToHTTP&&l&&new TextEncoder().encode(u).length>Ws){Y("/send-message",{nonce:l,messages:d}).then(T=>{!T.ok&&T.status===403&&c.reconnect()}),J("Message was too large for websockets and sent over HTTP instead");return}c.send(u)}const D=new Fe(o.staticSessionInfo,o.dynamicSessionInfo,o.myPresence,(d,u,l)=>{if(d===null||u===null)return null;{const m=He(u.scopes);return{connectionId:u.actor,id:d.userId,info:d.userInfo,presence:l,canWrite:m,canComment:$t(u.scopes),isReadOnly:!m}}});let U;function B(d){const u=D.current;u!==null&&u!==U&&(d(()=>{h.self.notify(u)}),U=u)}const oe=new Fe(D,d=>d!==null?It("Me",d):null);function E(d,u){if(d.items.length===0)throw new Error("Internal error: cannot load storage without items");o.root!==void 0?C(d.items,u):o.root=ee._fromItems(d.items,p);const l=o.undoStack.length;for(const m in o.initialStorage)o.root.get(m)===void 0&&o.root.set(m,Rs(o.initialStorage[m]));o.undoStack.length=l}function C(d,u){if(o.root===void 0)return;const l=new Map;for(const[T,M]of o.nodes)l.set(T,M._serialize());const m=Ms(l,new Map(d)),k=X(m,!1);j(k.updates,u)}function L(d,u){o.undoStack.length>=50&&o.undoStack.shift(),o.undoStack.push(d),Re(u)}function $(d,u){o.pausedHistory!==null?o.pausedHistory.unshift(...d):L(d,u)}function j(d,u){const l=d.storageUpdates,m=d.others;u(()=>{if(m!==void 0&&m.length>0){const k=o.others.current;for(const T of m)h.others.notify({...T,others:k})}if((d.presence??!1)&&(B(f),h.myPresence.notify(o.myPresence.current)),l!==void 0&&l.size>0){const k=Array.from(l.values());h.storage.notify(k)}be()})}function De(){const d=o.dynamicSessionInfo.current;if(d)return d.actor;throw new Error("Internal. Tried to get connection id but connection was never open")}function X(d,u){const l={reverse:[],storageUpdates:new Map,presence:!1},m=new Set,k=d.map(T=>T.type!=="presence"&&!T.opId?{...T,opId:p.generateOpId()}:T);for(const T of k)if(T.type==="presence"){const M={type:"presence",data:{}};for(const R in T.data)M.data[R]=o.myPresence.current[R];if(o.myPresence.patch(T.data),o.buffer.presenceUpdates===null)o.buffer.presenceUpdates={type:"partial",data:T.data};else for(const R in T.data)o.buffer.presenceUpdates.data[R]=T.data[R];l.reverse.unshift(M),l.presence=!0}else{let M;if(u)M=0;else{const we=S(T.opId);M=o.unacknowledgedOps.delete(we)?2:1}const R=ye(T,M);if(R.modified){const we=R.modified.node._id;we&&m.has(we)||(l.storageUpdates.set(S(R.modified.node._id),je(l.storageUpdates.get(S(R.modified.node._id)),R.modified)),l.reverse.unshift(...R.reverse)),(T.type===2||T.type===7||T.type===4)&&m.add(S(T.id))}}return{ops:k,reverse:l.reverse,updates:{storageUpdates:l.storageUpdates,presence:l.presence}}}function ye(d,u){if(Ts(d))return{modified:!1};switch(d.type){case 6:case 3:case 5:{const l=o.nodes.get(d.id);return l===void 0?{modified:!1}:l._apply(d,u===0)}case 1:{const l=o.nodes.get(d.id);return l===void 0?{modified:!1}:l.parent.type==="HasParent"&&qt(l.parent.node)?l.parent.node._setChildKey(_e(d.parentKey),l,u):{modified:!1}}case 4:case 2:case 7:case 8:{if(d.parentId===void 0)return{modified:!1};const l=o.nodes.get(d.parentId);return l===void 0?{modified:!1}:l._attachChild(d,u)}}}function Qt(d,u){const l={};o.buffer.presenceUpdates===null&&(o.buffer.presenceUpdates={type:"partial",data:{}});for(const m in d){const k=d[m];k!==void 0&&(o.buffer.presenceUpdates.data[m]=k,l[m]=o.myPresence.current[m])}o.myPresence.patch(d),o.activeBatch?(u!=null&&u.addToHistory&&o.activeBatch.reverseOps.unshift({type:"presence",data:l}),o.activeBatch.updates.presence=!0):(F(),_(()=>{u!=null&&u.addToHistory&&$([{type:"presence",data:l}],f),j({presence:!0},f)}))}function en(d){if(d.targetActor!==void 0){const l=o.others.getUser(d.actor);o.others.setOther(d.actor,d.data);const m=o.others.getUser(d.actor);if(l===void 0&&m!==void 0)return{type:"enter",user:m}}else o.others.patchOther(d.actor,d.data);const u=o.others.getUser(d.actor);if(u)return{type:"update",updates:d.data,user:u}}function tn(d){const u=o.others.getUser(d.actor);return u?(o.others.removeConnection(d.actor),{type:"leave",user:u}):null}function nn(d,u){o.dynamicSessionInfo.set({actor:d.actor,nonce:d.nonce,scopes:d.scopes}),o.idFactory=Js(d.actor),B(u);for(const l of o.others.connectionIds())d.users[l]===void 0&&o.others.removeConnection(l);for(const l in d.users){const m=d.users[l],k=Number(l);o.others.setConnection(k,m.id,m.info,m.scopes)}return{type:"reset"}}function nt(){return o.undoStack.length>0}function st(){return o.redoStack.length>0}function Re(d){d(()=>{h.history.notify({canUndo:nt(),canRedo:st()})})}function sn(d){o.others.setConnection(d.actor,d.id,d.info,d.scopes),o.buffer.messages.push({type:100,data:o.myPresence.current,targetActor:d.actor}),F();const u=o.others.getUser(d.actor);return u?{type:"enter",user:u}:void 0}function rt(d){return zs(d)?d:null}function rn(d){const u=Xe(d);return u===void 0?null:Gt(u)?ze(u.map(l=>rt(l))):ze([rt(u)])}function on(d,u){if(d.size===0)return;const l=[],m=Array.from(d.values()),k=X(m,!0);l.push({type:201,ops:k.ops}),j(k.updates,u),K(l)}function an(d){if(typeof d.data!="string")return;const u=rn(d.data);if(u===null||u.length===0)return;const l={storageUpdates:new Map,others:[]};_(()=>{for(const m of u)switch(m.type){case 101:{const k=sn(m);k&&l.others.push(k);break}case 100:{const k=en(m);k&&l.others.push(k);break}case 103:{const k=o.others.current;h.customEvent.notify({connectionId:m.actor,user:m.actor<0?null:k.find(T=>T.connectionId===m.actor)??null,event:m.event});break}case 102:{const k=tn(m);k&&l.others.push(k);break}case 300:{h.ydoc.notify(m);break}case 104:{l.others.push(nn(m,f));break}case 200:{ot(m);break}case 201:{const k=X(m.ops,!1);for(const[T,M]of k.updates.storageUpdates)l.storageUpdates.set(T,je(l.storageUpdates.get(T),M));break}case 299:{Lt("Storage mutation rejection error",m.reason);break}case 400:case 401:case 405:case 406:case 402:case 403:case 404:{h.comments.notify(m);break}}j(l,f)})}function F(){const d=o.buffer.storageOperations;if(d.length>0){for(const m of d)o.unacknowledgedOps.set(S(m.opId),m);be()}if(c.getStatus()!=="connected"){o.buffer.storageOperations=[];return}const u=Date.now(),l=u-o.buffer.lastFlushedAt;if(l>=e.throttleDelay){const m=cn();if(m.length===0)return;K(m),o.buffer={flushTimerID:void 0,lastFlushedAt:u,messages:[],storageOperations:[],presenceUpdates:null}}else clearTimeout(o.buffer.flushTimerID),o.buffer.flushTimerID=setTimeout(F,e.throttleDelay-l)}function cn(){const d=[];o.buffer.presenceUpdates&&d.push(o.buffer.presenceUpdates.type==="full"?{type:100,targetActor:-1,data:o.buffer.presenceUpdates.data}:{type:100,data:o.buffer.presenceUpdates.data});for(const u of o.buffer.messages)d.push(u);return o.buffer.storageOperations.length>0&&d.push({type:201,ops:o.buffer.storageOperations}),d}function dn(d,u){const l={type:301,update:d,guid:u};o.buffer.messages.push(l),h.ydoc.notify(l),F()}function un(d,u={shouldQueueEventIfNotReady:!1}){c.getStatus()!=="connected"&&!u.shouldQueueEventIfNotReady||(o.buffer.messages.push({type:103,event:d}),F())}function it(d){const{storageOperations:u}=o.buffer;for(const l of d)u.push(l);F()}let fe=null,ge=null;function ot(d){const u=new Map(o.unacknowledgedOps);E(d,f),on(u,f),ge==null||ge(),be(),h.storageDidLoad.notify()}async function ln(){if(!c.authValue)return;const u=await(await z(c.authValue,e.roomId)).json();ot({type:200,items:u})}function at(d){const u=o.buffer.messages;e.unstable_streamData?ln():u.some(l=>l.type===200)||u.push({type:200}),d.flush&&F()}function ct(){return fe===null&&(at({flush:!0}),fe=new Promise(d=>{ge=d}),be()),fe}function fn(){const d=o.root;return d!==void 0?d:(ct(),null)}async function hn(){return o.root!==void 0?Promise.resolve({root:o.root}):(await ct(),{root:S(o.root)})}function pn(d,u){o.buffer.messages.find(l=>l.type===300&&l.vector===d&&l.guid===u)||o.buffer.messages.push({type:300,vector:d,guid:u}),F()}function mn(){if(o.activeBatch)throw new Error("undo is not allowed during a batch");const d=o.undoStack.pop();if(d===void 0)return;o.pausedHistory=null;const u=X(d,!0);_(()=>{j(u.updates,f),o.redoStack.push(u.reverse),Re(f)});for(const l of u.ops)l.type!=="presence"&&o.buffer.storageOperations.push(l);F()}function _n(){if(o.activeBatch)throw new Error("redo is not allowed during a batch");const d=o.redoStack.pop();if(d===void 0)return;o.pausedHistory=null;const u=X(d,!0);_(()=>{j(u.updates,f),o.undoStack.push(u.reverse),Re(f)});for(const l of u.ops)l.type!=="presence"&&o.buffer.storageOperations.push(l);F()}function yn(){o.undoStack.length=0,o.redoStack.length=0}function gn(d){if(o.activeBatch)return d();let u;return _(()=>{o.activeBatch={ops:[],updates:{storageUpdates:new Map,presence:!1,others:[]},reverseOps:[]};try{u=d()}finally{const l=o.activeBatch;o.activeBatch=null,l.reverseOps.length>0&&$(l.reverseOps,f),l.ops.length>0&&(o.redoStack.length=0),l.ops.length>0&&it(l.ops),j(l.updates,f),F()}}),u}function vn(){o.pausedHistory===null&&(o.pausedHistory=[])}function bn(){const d=o.pausedHistory;o.pausedHistory=null,d!==null&&d.length>0&&L(d,_)}function ve(){return o.root===void 0?fe===null?"not-loaded":"loading":o.unacknowledgedOps.size===0?"synchronized":"synchronizing"}let dt=ve();function be(){const d=ve();dt!==d&&(dt=d,h.storageStatus.notify(d))}const wn=new Fe(o.others,d=>d.map((u,l)=>It(`Other ${l}`,u))),ut={status:h.status.observable,lostConnection:h.lostConnection.observable,customEvent:h.customEvent.observable,others:h.others.observable,self:h.self.observable,myPresence:h.myPresence.observable,error:h.error.observable,storage:h.storage.observable,history:h.history.observable,storageDidLoad:h.storageDidLoad.observable,storageStatus:h.storageStatus.observable,ydoc:h.ydoc.observable,comments:h.comments.observable},In=Gs(e.roomId,a.authenticate,A);async function Me(d,u){const l=await a.authenticate(),m=await A(e.roomId,d,l,u);if(!m.ok&&m.status>=400&&m.status<600){let T;try{const M=await m.json();T=new Ae(M.message,m.status,M)}catch{T=new Ae(m.statusText,m.status)}throw T}let k;try{k=await m.json()}catch{k={}}return k}function Sn(){return Me("/notification-settings")}function kn(d){return Me("/notification-settings",{method:"POST",body:JSON.stringify(d),headers:{"Content-Type":"application/json"}})}async function On(d){await Me("/inbox-notifications/read",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({inboxNotificationIds:d})})}const Tn=new Ze(async d=>{const u=d.flat();return await On(u),u},{delay:Ys});async function En(d){await Tn.get(d)}return Object.defineProperty({[Ce]:{get presenceBuffer(){var d;return me(((d=o.buffer.presenceUpdates)==null?void 0:d.data)??null)},get undoStack(){return me(o.undoStack)},get nodeCount(){return o.nodes.size},getSelf_forDevTools:()=>oe.current,getOthers_forDevTools:()=>wn.current,simulate:{explicitClose:d=>c._privateSendMachineEvent({type:"EXPLICIT_SOCKET_CLOSE",event:d}),rawSend:d=>c.send(d)},comments:{...In},notifications:{getRoomNotificationSettings:Sn,updateRoomNotificationSettings:kn,markInboxNotificationAsRead:En}},id:e.roomId,subscribe:Zs(ut),connect:()=>c.connect(),reconnect:()=>c.reconnect(),disconnect:()=>c.disconnect(),destroy:()=>{i(),c.destroy()},updatePresence:Qt,updateYDoc:dn,broadcastEvent:un,batch:gn,history:{undo:mn,redo:_n,canUndo:nt,canRedo:st,clear:yn,pause:vn,resume:bn},fetchYDoc:pn,getStorage:hn,getStorageSnapshot:fn,getStorageStatus:ve,events:ut,getStatus:()=>c.getStatus(),getConnectionState:()=>c.getLegacyStatus(),getSelf:()=>D.current,getPresence:()=>o.myPresence.current,getOthers:()=>o.others.current},Ce,{enumerable:!1})}function Zs(t){function e(r,i){return t.storage.subscribe(a=>{const c=a.filter(o=>Wt(o.node,r));c.length>0&&i(c)})}function n(r,i){return t.storage.subscribe(a=>{for(const c of a)c.node._id===r._id&&i(c.node)})}function s(r,i,a){if(typeof r=="string"&&Qs(r)){if(typeof i!="function")throw new Error("Second argument must be a callback function");const c=i;switch(r){case"event":return t.customEvent.subscribe(c);case"my-presence":return t.myPresence.subscribe(c);case"others":{const o=c;return t.others.subscribe(f=>{const{others:_,...b}=f;return o(_,b)})}case"error":return t.error.subscribe(c);case"connection":{const o=c;return t.status.subscribe(f=>o(xt(f)))}case"status":return t.status.subscribe(c);case"lost-connection":return t.lostConnection.subscribe(c);case"history":return t.history.subscribe(c);case"storage-status":return t.storageStatus.subscribe(c);default:return W(r,`"${String(r)}" is not a valid event name`)}}if(i===void 0||typeof r=="function")if(typeof r=="function"){const c=r;return t.storage.subscribe(c)}else throw new Error("Please specify a listener callback");if(x(r)){const c=r;return a!=null&&a.isDeep?e(c,i):n(c,i)}throw new Error(`${String(r)} is not a value that can be subscribed to.`)}return s}function Qs(t){return t==="my-presence"||t==="others"||t==="event"||t==="error"||t==="history"||t==="status"||t==="storage-status"||t==="lost-connection"||t==="connection"}function er(t,e){return async()=>e.getAuthValue({requestedScope:"room:read",roomId:t})}function tr(t,e,n){return s=>{const r=n??(typeof WebSocket>"u"?void 0:WebSocket);if(r===void 0)throw new Z("To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.");const i=new URL(e);if(i.protocol=i.protocol==="http:"?"ws":"wss",i.pathname="/v7",i.searchParams.set("roomId",t),s.type==="secret")i.searchParams.set("tok",s.token.raw);else if(s.type==="public")i.searchParams.set("pubkey",s.publicApiKey);else return W(s,"Unhandled case");return i.searchParams.set("version",Ot),new r(i.toString())}}function nr(){const t=jt({threads:{},queries:{},optimisticUpdates:[],inboxNotifications:{},notificationSettings:{}});return{...t,deleteThread(e){t.set(n=>({...n,threads:sr(n.threads,e),inboxNotifications:Object.fromEntries(Object.entries(n.inboxNotifications).filter(([s,r])=>r.threadId!==e))}))},updateThreadAndNotification(e,n){t.set(s=>{const r=s.threads[e.id];return{...s,threads:r===void 0||Xt(e,r)===1?{...s.threads,[e.id]:e}:s.threads,inboxNotifications:n===void 0?s.inboxNotifications:{...s.inboxNotifications,[n.id]:n}}})},updateThreadsAndNotifications(e,n,s,r,i){t.set(a=>({...a,threads:rr(a.threads,{newThreads:e,deletedThreads:s}),inboxNotifications:ir(a.inboxNotifications,{newInboxNotifications:n,deletedNotifications:r}),queries:i!==void 0?{...a.queries,[i]:{isLoading:!1}}:a.queries}))},updateRoomInboxNotificationSettings(e,n,s){t.set(r=>({...r,notificationSettings:{...r.notificationSettings,[e]:n},queries:{...r.queries,[s]:{isLoading:!1}}}))},pushOptimisticUpdate(e){t.set(n=>({...n,optimisticUpdates:[...n.optimisticUpdates,e]}))},setQueryState(e,n){t.set(s=>({...s,queries:{...s.queries,[e]:n}}))}}}function sr(t,e){if(Object.prototype.hasOwnProperty.call(t,e)){const{[e]:n,...s}=t;return s}return t}function Xt(t,e){return t.updatedAt&&e.updatedAt?t.updatedAt>e.updatedAt?1:t.updatedAt<e.updatedAt?-1:0:t.updatedAt||e.updatedAt?t.updatedAt?1:-1:t.createdAt>e.createdAt?1:t.createdAt<e.createdAt?-1:0}function rr(t,e){const n={...t};return e.newThreads.forEach(s=>{const r=n[s.id];r&&Xt(r,s)===1||(n[s.id]=s)}),e.deletedThreads.forEach(({id:s,deletedAt:r})=>{const i=n[s];i!==void 0&&(i.deletedAt=r,i.updatedAt=r,i.comments=[])}),n}function ir(t,e){const n={...t};return e.newInboxNotifications.forEach(s=>{const r=n[s.id];r&&or(r,s)===1||(n[s.id]=s)}),e.deletedNotifications.forEach(({id:s})=>delete n[s]),n}function or(t,e){return t.notifiedAt>e.notifiedAt?1:t.notifiedAt<e.notifiedAt?-1:t.readAt&&e.readAt?t.readAt>e.readAt?1:t.readAt<e.readAt?-1:0:t.readAt||e.readAt?t.readAt?1:-1:0}var ar=16,cr=1e3,dr=100,ur=15e3,lr=200,fr=1e3,hr=3e4,pr=5e3,mr=50,_r=50;function yr(t){return typeof t=="string"&&t.startsWith("http")?t:cs}function Ye(t){return t.type==="public"?t.publicApiKey:t.token.raw}function gr(t){var oe;const e=t,n=br(e.throttle??dr),s=wr(e.lostConnectionTimeout??pr),r=vr(e.backgroundKeepAliveTimeout),i=yr(e.baseUrl),a=is(t),c=new Map;function o(E){E.id,c.delete(E.id),E.destroy()}function f(E){const C=()=>{const L=C;E.unsubs.delete(L)?E.unsubs.size===0&&o(E.room):J("This leave function was already called. Calling it more than once has no effect.")};return E.unsubs.add(C),{room:E.room,leave:C}}function _(E,C){var X,ye;const L=c.get(E);if(L!==void 0)return f(L);C.initialPresence===null||C.initialPresence;const $=Xs({initialPresence:C.initialPresence??{},initialStorage:C.initialStorage},{roomId:E,throttleDelay:n,lostConnectionTimeout:s,backgroundKeepAliveTimeout:r,polyfills:e.polyfills,delegates:e.mockedDelegates??{createSocket:tr(E,i,(X=e.polyfills)==null?void 0:X.WebSocket),authenticate:er(E,a)},enableDebugLogging:e.enableDebugLogging,unstable_batchedUpdates:C==null?void 0:C.unstable_batchedUpdates,baseUrl:i,unstable_fallbackToHTTP:!!e.unstable_fallbackToHTTP,unstable_streamData:!!e.unstable_streamData}),j={room:$,unsubs:new Set};if(c.set(E,j),C.autoConnect??C.shouldInitiallyConnect??!0){if(typeof atob>"u"){if(((ye=e.polyfills)==null?void 0:ye.atob)===void 0)throw new Error("You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill");global.atob=e.polyfills.atob}$.connect()}return f(j)}function b(E,C){const{room:L,leave:$}=_(E,C);return L}function y(E){var L;const C=(L=c.get(E))==null?void 0:L.room;return C||null}function I(E){var L;const C=((L=c.get(E))==null?void 0:L.unsubs)??new Set;for(const $ of C)$()}function g(){a.reset();for(const{room:E}of c.values())Wn(E.getStatus())||E.reconnect()}const v=jt(null),{getInboxNotifications:w,getUnreadInboxNotificationsCount:O,markAllInboxNotificationsAsRead:p,markInboxNotificationAsRead:h}=_s({baseUrl:i,fetcher:((oe=e.polyfills)==null?void 0:oe.fetch)||fetch,authManager:a,currentUserIdStore:v}),A=nr(),z=e.resolveUsers,Y=kt(()=>!z,"Set the resolveUsers option in createClient to specify user info."),K=gt(async E=>{const C=E.flat(),L=await(z==null?void 0:z({userIds:C}));return Y(),L??C.map(()=>{})},{delay:mr}),D=e.resolveRoomsInfo,U=kt(()=>!D,"Set the resolveRoomsInfo option in createClient to specify room info."),B=gt(async E=>{const C=E.flat(),L=await(D==null?void 0:D({roomIds:C}));return U(),L??C.map(()=>{})},{delay:_r});return Object.defineProperty({logout:g,enter:b,getRoom:y,leave:I,enterRoom:_,[Ce]:{notifications:{getInboxNotifications:w,getUnreadInboxNotificationsCount:O,markAllInboxNotificationsAsRead:p,markInboxNotificationAsRead:h},currentUserIdStore:v,resolveMentionSuggestions:e.resolveMentionSuggestions,cacheStore:A,usersStore:K,roomsInfoStore:B,getRoomIds(){return Array.from(c.keys())}}},Ce,{enumerable:!1})}var Ae=class extends Error{constructor(t,e,n){super(t),this.message=t,this.status=e,this.details=n}};function tt(t,e,n,s,r){if(typeof e!="number"||e<n||s!==void 0&&e>s)throw new Error(s!==void 0?`${t} should be between ${r??n} and ${s}.`:`${t} should be at least ${r??n}.`);return e}function vr(t){if(t!==void 0)return tt("backgroundKeepAliveTimeout",t,ur)}function br(t){return tt("throttle",t,ar,cr)}function wr(t){return tt("lostConnectionTimeout",t,lr,hr,fr)}function kt(t,...e){return()=>{}}var Ir={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"};new RegExp(Object.keys(Ir).map(t=>`\\${t}`).join("|"),"g");var Sr={_:"\\_","*":"\\*","#":"\\#","`":"\\`","~":"\\~","!":"\\!","|":"\\|","(":"\\(",")":"\\)","{":"\\{","}":"\\}","[":"\\[","]":"\\]"};new RegExp(Object.keys(Sr).map(t=>`\\${t}`).join("|"),"g");Tt(Pn,Ot,Ln);var kr="@liveblocks/client",Or="1.11.3",Tr="esm";Tt(kr,Or,Tr);const Zt={createClient:gr,LiveList:re,LiveMap:ie,LiveObject:ee};window.liveblocks=Zt;document.dispatchEvent(new CustomEvent("liveblocks",{detail:Zt}));
//# sourceMappingURL=index.js.map
